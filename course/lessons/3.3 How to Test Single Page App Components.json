{"components":[{"type":"MarkdownEditor","content":{"version":"2.0","text":"We'll be looking at class-based SPA components. [Angular](https://angular.io/guide/component-overview#creating-a-component-manually), [React](https://reactjs.org/docs/state-and-lifecycle.html#adding-local-state-to-a-class), and [Vue](https://class-component.vuejs.org/) support such class based components.\n\nSPA components generally expose lifecycle hooks (or methods) that can be used to do certain actions at certain times. For example, wait till the component is initialized (or mounted/displayed) before making a call to the API to fetch some data. And at the time of its destruction(or unmount) stop any further processing.\n\nExamples of component lifecycle hooks from some SPA frameworks:\n\n- [Angular docs](https://angular.io/guide/lifecycle-hooks#initializing-a-component-or-directive)\n- [React docs](https://reactjs.org/docs/react-component.html#componentdidmount)\n- [Vue docs](https://vuejs.org/v2/api/#mounted)\n\n## The component - ArticleComponent\n\nFor this lesson, we'll use a SPA Component that displays an article like in a blog. It loads the article at the time of its initialization. At the time of its destruction, it marks itself destroyed and will not show the article.\n\nIn the code playground below there's an implementation of the ArticleComponent and its tests. Let's run them and see their breakdown below.","mdHtml":"<p>We’ll be looking at class-based SPA components. <a href=\"https://angular.io/guide/component-overview#creating-a-component-manually\">Angular</a>, <a href=\"https://reactjs.org/docs/state-and-lifecycle.html#adding-local-state-to-a-class\">React</a>, and <a href=\"https://class-component.vuejs.org/\">Vue</a> support such class based components.</p>\n<p>SPA components generally expose lifecycle hooks (or methods) that can be used to do certain actions at certain times. For example, wait till the component is initialized (or mounted/displayed) before making a call to the API to fetch some data. And at the time of its destruction(or unmount) stop any further processing.</p>\n<p>Examples of component lifecycle hooks from some SPA frameworks:</p>\n<ul>\n<li><a href=\"https://angular.io/guide/lifecycle-hooks#initializing-a-component-or-directive\">Angular docs</a></li>\n<li><a href=\"https://reactjs.org/docs/react-component.html#componentdidmount\">React docs</a></li>\n<li><a href=\"https://vuejs.org/v2/api/#mounted\">Vue docs</a></li>\n</ul>\n<h2>The component - ArticleComponent</h2>\n<p>For this lesson, we’ll use a SPA Component that displays an article like in a blog. It loads the article at the time of its initialization. At the time of its destruction, it marks itself destroyed and will not show the article.</p>\n<p>In the code playground below there’s an implementation of the ArticleComponent and its tests. Let’s run them and see their breakdown below.</p>\n","cursorPosition":1327,"comp_id":"RHwnzqcFajHwQCPVw0M4O"},"iteration":2,"hash":1,"saveVersion":1},{"type":"WebpackBin","mode":"edit","content":{"version":4,"theme":"default","showLineNumbers":true,"showConsole":false,"hideResultOutput":true,"hideOutputUrl":true,"hideCodeView":false,"loaders":{"babel":{"title":"React","config":{"es2015":true,"react":true},"enabled":true},"dart":{"title":"Dart","config":{"dart":true},"enabled":false},"ts-react":{"title":"Typescript React","config":{"ts-react":true},"enabled":false},"elm":{"title":"Elm","config":{"elm":true},"enabled":false},"vue":{"title":"Vue.js","config":{"vue":true},"enabled":false},"gojs-react":{"title":"GoJS React","config":{"gojs-react":true},"enabled":false}},"npmPackages":{"react":"15.6.1","react-dom":"15.6.1"},"outputHeight":300,"selectedApiKeys":{},"selectedEnvVars":{},"outputLayout":"desktop","codeContents":{"module":"/","id":0,"selectedId":6598782013128,"maxId":2252865300030,"children":[{"id":9454697242372,"module":"spec","leaf":false,"collapsed":true,"children":[{"id":7445976935575,"module":"support","leaf":false,"collapsed":true,"children":[{"id":5959127878721,"module":"jasmine-browser.js","leaf":true,"data":{"content":"const specReporter = require('jasmine-spec-reporter').SpecReporter\n\nmodule.exports = {\n  srcDir: \"src\",\n  srcFiles: [\n    \"**/*.?(m)js\"\n  ],\n  specDir: \"spec\",\n  specFiles: [\n    \"**/*[sS]pec.?(m)js\"\n  ],\n  helpers: [\n    \"helpers/**/*.?(m)js\"\n  ],\n  random: false,\n  stopSpecOnExpectationFailure: false,\n  browser: {\n    name: \"headlessChrome\"\n  },\n  reporters: [new specReporter()]\n}\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""}}]},{"id":6598782013128,"module":"article-component.spec.mjs","leaf":true,"data":{"content":"import { ArticleComponent } from '../__src__/article.component.mjs';\n\ndescribe('ArticleComponent', () => {\n  let component;\n  let articleAPI;\n  let userMessenger;\n\n  beforeEach(() => {\n    articleAPI = jasmine.createSpyObj('article API', {\n      get: Promise.resolve({ id: 1, title: 'first', content: 'article' }),\n    });\n    userMessenger = jasmine.createSpyObj('userMessenger', ['info', 'error']);\n    component = new ArticleComponent(articleAPI, userMessenger);\n  });\n\n  it(`when initialized it should call the articleAPI get and assign the result to the article property`, async () => {\n    // arrange\n    component.articleId = 1;\n    // act\n    await component.afterComponentInitialize();\n    // assert\n    expect(articleAPI.get).toHaveBeenCalledOnceWith(1);\n    expect(component.article).toEqual(jasmine.objectContaining({ id: 1 }));\n  });\n\n  it(`when initialized it should call the articleAPI get and inform user upon article fetch failed`, async () => {\n    // arrange\n    component.articleId = 1;\n    articleAPI.get.and.returnValue(Promise.reject('error'));\n    // act\n    await component.afterComponentInitialize();\n    // assert\n    expect(userMessenger.error).toHaveBeenCalledOnceWith('Could not fetch article id: \"1\". Please try again.');\n  });\n\n  it(`when initialized it should set loading to true and back to false after the article response arrives`, async () => {\n    // arrange\n    articleAPI.get.and.returnValue(Promise.resolve({ id: 1 }));\n    component.articleId = 1;\n    // act\n    const initPromise = component.afterComponentInitialize();\n    // assert\n    expect(component.loading).toBe(true);\n    await initPromise;\n    expect(component.loading).toBe(false);\n  });\n\n  it(`when initialized it should set loading to true and back to false even after article fetch fails`, async () => {\n    // arrange\n    articleAPI.get.and.returnValue(Promise.reject({ message: 'error' }));\n    component.articleId = 1;\n    // act\n    const initPromise = component.afterComponentInitialize();\n    // assert\n    expect(component.loading).toBe(true);\n    await initPromise;\n    expect(component.loading).toBe(false);\n  });\n\n  it(`when destroyed it should not set the article property`, async () => {\n    // arrange\n    component.articleId = 1;\n    articleAPI.get.and.returnValue(Promise.resolve({id: 1, title: 'will not be shown to user because the component was destroyed'}));\n    const initPromise = component.afterComponentInitialize();\n    // act\n    component.beforeComponentDestroy();\n    await initPromise;\n    // assert\n    expect(component.article).toBeUndefined();\n  });\n\n  it(`when destroyed it should not inform user upon article fetch failed`, async () => {\n    // arrange\n    component.articleId = 1;\n    articleAPI.get.and.returnValue(Promise.reject('error'));\n    const initPromise = component.afterComponentInitialize();\n    // act\n    component.beforeComponentDestroy();\n    await initPromise;\n    // assert\n    expect(userMessenger.error).not.toHaveBeenCalledOnceWith('Could not fetch article id: \"1\". Please try again.');\n  });\n});\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""}}]},{"id":2252865300030,"module":"src","leaf":false,"collapsed":true,"children":[{"id":7061913124153,"module":"article-api.mjs","leaf":true,"data":{"content":"export class ArticleAPI {\n  get(id) {\n    // make a GET /api/article/:id request (XMLHttpRequest/fetch/axios)\n    // and return a promise\n  }\n\n  delete(id) {\n    // make a DELETE /api/article/:id request (XMLHttpRequest/fetch/axios)\n    // and return a promise\n  }\n\n  create(title, content) {\n    // make a POST /api/article request (XMLHttpRequest/fetch/axios)\n    // and return a promise\n  }\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""}},{"id":3214653694011,"module":"article.component.mjs","leaf":true,"data":{"content":"export class ArticleComponent {\n  articleId; // or props.articleId\n\n  article;\n  loading;\n  destroyed;\n\n  articleAPI;\n  userMessenger;\n\n  constructor(articleApi, userMessenger) {\n    this.articleAPI = articleApi;\n    this.userMessenger = userMessenger;\n  }\n\n  async afterComponentInitialize() {\n    this.loading = true;\n    try {\n      const article = await this.articleAPI.get(this.articleId);\n      if(!this.destroyed) {\n        this.article = article;\n      }\n    } catch {\n      if(!this.destroyed) {\n        this.userMessenger.error(`Could not fetch article id: \"${this.articleId}\". Please try again.`);\n      }\n    }\n    this.loading = false;\n  }\n\n  beforeComponentDestroy() {\n    this.destroyed = true;\n    this.article = undefined;\n  }\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""}},{"id":520137454511,"module":"user-messanger.mjs","leaf":true,"data":{"content":"export class UserMessenger {\n    info() {\n        // show an info message (e.g. a snack)\n    }\n    error() {\n        // show an error message (e.g. a snack)\n    }\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""}}]}],"importedGithubPath":"https://github.com/gparlakov/jasmine-educative/tree/main/3.3.spa-component"},"dockerJob":{"key":"MAg0aPm2NgdrpUzSEzwM0","name":"Run jasmine-browser-runner console","inputFileName":"index.js","runScript":"cp -r /usercode/** .","ports":"3000","startScript":"cd /usr/local/educative/unit-testing-course && \nnpx nodemon -w /usercode --exec \"cp -r /usercode/** . && npx jasmine-browser-runner runSpecs\"","jobType":"Live","forceRelaunchOnRun":false,"forceRelaunchOnCompChange":true,"runInLiveContainer":true},"caption":"Example of testing asynchronous SPA lifecycle hook methods","comp_id":"syGo1JifI-u7Zh9P50Ubi"},"iteration":10,"hash":2,"saveVersion":1},{"type":"MarkdownEditor","mode":"edit","content":{"version":"2.0","text":"\n## Breakdown - ArticleComponent\n\nLooking at the `src/article.component.mjs`:\n\n- ```js\n  export class ArticleComponent {\n    articleId; // or props.articleId\n\n    article;\n    loading;\n    destroyed;\n    //...\n  }\n  ```\n\n  We start by declaring the class of the component and declaring some properties in it:\n\n  - The `articleId` is the id of the article the component is to display. This is expected to be an input (or prop) i.e. the component relies on it being there to be able to do its job. Examples: [Angular Input](https://angular.io/guide/inputs-outputs#sending-data-to-a-child-component), [React prop](https://reactjs.org/docs/components-and-props.html#rendering-a-component), [Vue prop](https://v3.vuejs.org/guide/component-props.html#passing-static-or-dynamic-props).\n  - The `article` will hold a reference to the article object that is going to be fetched from the `ArticleAPI`.\n  - The `loading` is the property that lets us show/hide a loading spinner to the user to let them know something is afoot.\n  - The `destroyed` is the property will become true when the component is being destroyed. It will be used to stop any further processing at that point.\n\n- ```js\n  articleAPI;\n  userMessenger;\n\n  constructor(articleApi, userMessenger) {\n    this.articleAPI = articleApi;\n    this.userMessenger = userMessenger;\n  }\n  ```\n\n  - The `articleAPI` is the instance that lets us call the server API endpoint to get the article or delete it.\n  - The `userMessenger` is an instance of the `UserMessenger` class that will show a message to the user. It can be of the `info` or `error` category using the correspondingly named method of that class.\n  - In the `constructor` we populate the `articleAPI` and the `userMessenger` properties with the passed-in instances.\n\n- ```js\n  async afterComponentInitialize() {\n    this.loading = true;\n    try {\n      const article = await this.articleAPI.get(this.articleId);\n      if(!this.destroyed) {\n        this.article = article;\n      }\n    } catch {\n      if(!this.destroyed) {\n        this.userMessenger.error(`Could not fetch article id: \"${this.articleId}\". Please try again.`);\n      }\n    }\n    this.loading = false;\n  }\n  ```\n\n  This method is a \"hook\" that will get called by the framework (e.g. Angular or React) after the component initializes and is ready to take the data and display it. It's an `async` method that allows us to use `await` within it.\n\n  The `this.loading = true;` line sets up the loading state so that a user will see a spinner indicating something is going on in the background.\n\n- ```js\n  try {\n    const article = await this.articleAPI.get(this.articleId);\n    if (!this.destroyed) {\n      this.article = article;\n    }\n  }\n  ```\n\n  Wrapping the logic in a `try catch` to make sure if the api call throws, we catch the error and handle it (handling logic is next).\n\n  The `this.articleAPI.get(this.articleId)` call is asynchronous (i.e. it returns a `Promise`) so we `await` it and get the response in the `article` local constant.\n\n  If the component has been destroyed there is no point to populate the article property so we skip it. This check is largely not necessary for such a straightforward component logic. It serves to demonstrate the \"do not process any more logic after the component has been destroyed\" approach which serves to effectively cancel any further calculations and stop potential memory leaks. ([Memory leaks in JavaScript article](https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/#Further-reading))\n\n  In essence, this check is here so we can demo how to test such logic.\n\n- ```js\n  try {\n    // ... skipped\n  } catch {\n    if (!this.destroyed) {\n      this.userMessenger.error(`Could not fetch article id: \"${this.articleId}\". Please try again.`);\n    }\n  }\n  ```\n\n  In the case of an error returned from the server (400 or 500) we expect the `Promise` will get rejected so we handle that case. Handle it by showing relevant information to the user and potentially how they can resolve this situation.\n\n  Again, this logic is wrapped in a check if the component has been destroyed. This is to handle a case similar to:\n\n  - User opens the article.\n  - Spinner appears.\n  - Response takes a lot of time, and the spinner stays on.\n  - User closes the article component (e.g. navigates back).\n  - Component gets destroyed at this time.\n  - Response arrives after that and is an error (500).\n  - Showing an error at this time will be confusing for the user who is in a different context now e.g. the article list page. Hence the check if the component has been destroyed before showing the error.\n\n- ```js\n  beforeComponentDestroy() {\n    this.destroyed = true;\n    this.article = undefined;\n  }\n  ```\n\n  This is the \"hook\" that gets called by the framework when component destruction is about to happen. After this call, the framework (e.g. Angular or React) will remove the component from the DOM and discard it.\n\n  We mark this component instance as `destroyed` and also discard any `article` object the component might hold a reference to, thus resetting it.\n\n## Breakdown - tests\n\nWe'll test the two \"hook\" methods. There's a new challenge for the tests: The \"hook\" `beforeComponentDestroy` method changes the behavior of the `afterComponentInitialize` while the `afterComponentInitialize` is still being processed.\n\nLet's look at `spec/article-component.spec.mjs`:\n\n- ```js\n  import { ArticleComponent } from '../__src__/article.component.mjs';\n  ```\n\n  We start by importing the `ArticleComponent`.\n\n- ```js\n  describe('ArticleComponent', () => {\n    let component;\n    let articleAPI;\n    let userMessenger;\n  ```\n\n  We define a test suite `ArticleComponent`.\n\n- ```js\n  let component;\n  let articleAPI;\n  let userMessenger;\n\n  beforeEach(() => {\n    articleAPI = jasmine.createSpyObj('article API', {\n      get: Promise.resolve({ id: 1, title: 'first', content: 'article' }),\n    });\n    userMessenger = jasmine.createSpyObj('userMessenger', ['info', 'error']);\n    component = new ArticleComponent(articleAPI, userMessenger);\n  });\n  ```\n\n  We define some variables that will be available for every test. They get reset before each test in the `beforeEach` Jasmine \"hook\".\n\n  - The `articleAPI` uses a different `createSpyObj` method overload which allows us to define the default response. In this case, we instruct Jasmine to create a spy for the `get` method of the `ArticleAPI` instance and return a Promise resolving to an article.\n  - The `userMessenger` is also a spy object, and it defines multiple methods for Jasmine to spy on `['info', 'error'].\n  - The `component` is reset to a new instance before every test, making each test separate and independent of the rest.\n\n### Test case `when initialized it should call the articleAPI get and assign the result to the article property`\n\n```js\nit(`when initialized it should call the articleAPI get and assign the result to the article property`, async () => {\n  // arrange\n  component.articleId = 1;\n  // act\n  await component.afterComponentInitialize();\n  // assert\n  expect(articleAPI.get).toHaveBeenCalledOnceWith(1);\n  expect(component.article).toEqual(jasmine.objectContaining({ id: 1 }));\n});\n```\n\nIn the above test case, we'll make sure the article is assigned to the `article` property of the component when the server response arrives:\n\n- Provide the component with an article id.\n- Call the `afterComponentInitialize` method, simulating what a framework will do.\n- Make sure that `get` was called with the expected `id`, and the article returned is an object that contains the `id: 1` in it.\n  - The `id: 1, title: ...` was set in the default response for `get` in the `beforeEach` above and not in the test itself.\n\n### Test case `when initialized it should call the articleAPI get and inform user upon article fetch failed`\n\n```js\nit(`when initialized it should call the articleAPI get and inform user upon article fetch failed`, async () => {\n  // arrange\n  component.articleId = 1;\n  articleAPI.get.and.returnValue(Promise.reject('error'));\n  // act\n  await component.afterComponentInitialize();\n  // assert\n  expect(userMessenger.error).toHaveBeenCalledOnceWith('Could not fetch article id: \"1\". Please try again.');\n});\n```\n\nIn the above test case, we'll make sure that the user gets notified of an error via the `userMessenger.error` method when an error happens i.e. the response is 4xx or 5xx:\n\n- Provide the component with an article `id`.\n- Provide `articleAPI.get` a promise that is rejected. That is the failing scenario.\n- Call the `returnValue`.\n- Assert that the `error` method of `userMessenger` has been called as expected.\n\n### Test case `when initialized it should set loading to true and back to false after the article response arrives`\n\n```js\nit(`when initialized it should set loading to true and back to false after the article response arrives`, async () => {\n  // arrange\n  articleAPI.get.and.returnValue(Promise.resolve({ id: 1 }));\n  component.articleId = 1;\n  // act\n  const initPromise = component.afterComponentInitialize();\n  // assert\n  expect(component.loading).toBe(true);\n  await initPromise;\n  expect(component.loading).toBe(false);\n});\n```\n\nIn the above test case, we'll make sure the `loading` is `true` while the component waits for the article to arrive, and then it turns to `false`:\n\n- We start by providing the return value `Promise.resolve({id: 1})`. Since it's valuable for the outcome of the test, we explicitly provide it. It's valuable because if the Promise is rejected the test will fail.\n- We need to control when the `Promise` is resolved i.e. when the server responds so that we're able to verify the `loading` is `true` in the meantime.\n- We store the promise in `initPromise` local constant and not `await` it until we've asserted that the value of `loading` is `true`.\n- We assert the `loading` is `true`\n- We `await initPromise` simulating the wait until the response arrives and assert the `loading` is now `false`.\n\n### Test case `when initialized it should set loading to true and back to false even after article fetch fails`\n\n```js\nit(`when initialized it should set loading to true and back to false even after article fetch fails`, async () => {\n  // arrange\n  articleAPI.get.and.returnValue(Promise.reject({ message: 'error' }));\n  component.articleId = 1;\n  // act\n  const initPromise = component.afterComponentInitialize();\n  // assert\n  expect(component.loading).toBe(true);\n  await initPromise;\n  expect(component.loading).toBe(false);\n});\n```\n\nIn the above test case, we'll make sure that `loading` behaves correctly in case of an error. So it turns `true` while waiting for the response and `false` when the response arrives.\n\n- We start providing a rejected `Promise` as the `articleAPI.get` response.\n- We store the `Promise` in the `initPromise` constant and not `await` it.\n- We assert the `loading` is `true` while waiting for the response.\n- We `await initPromise` to simulate the response arriving.\n- We assert the `loading` is now `false` even though an error happened.\n\n### Test case `when destroyed it should not set the article property`\n\n```js\nit(`when destroyed it should not set the article property`, async () => {\n  // arrange\n  component.articleId = 1;\n  articleAPI.get.and.returnValue(\n    Promise.resolve({ id: 1, title: 'will not be shown to user because the component was destroyed' })\n  );\n  const initPromise = component.afterComponentInitialize();\n  // act\n  component.beforeComponentDestroy();\n  await initPromise;\n  // assert\n  expect(component.article).toBeUndefined();\n});\n```\n\nIn the above test case, we'll make sure that (1) the `article` property does not get populated in a (2) destroyed component. That simulates a case where the user decided to navigate away from the current page, and while the new page intent is getting processed by the routing logic, the article response arrives. In that case, we don't want to show the article info for a split second and then close it (it might cause a flash of content issue).\n\n- We start by providing a good response by the `articleAPI.get`.\n- We call the `afterComponentInitialize` and store its result, the `initPromise` in a constant, and not `await` it. That allows us to destroy the component before the response arrives, simulating the second part (2) of the condition above.\n- We call the `beforeComponentDestroy` to simulate the first part (1) of the condition above.\n- We `await initPromise` simulating the response arriving.\n- We assert that the `article` property is indeed `undefined` as expected.\n\n### Test case `when destroyed it should not inform user upon article fetch failed`\n\n```js\nit(`when destroyed it should not inform user upon article fetch failed`, async () => {\n  // arrange\n  component.articleId = 1;\n  articleAPI.get.and.returnValue(Promise.reject('error'));\n  const initPromise = component.afterComponentInitialize();\n  // act\n  component.beforeComponentDestroy();\n  await initPromise;\n  // assert\n  expect(userMessenger.error).not.toHaveBeenCalledOnceWith('Could not fetch article id: \"1\". Please try again.');\n});\n```\n\nIn the above test case, we'll make sure that the user is not notified of an error after they've decided to navigate away from this component e.g. if the response took too long and timed out.\n\n- We provide a rejected `Promise` to the `articleAPI.get` simulating the timed-out response.\n- We invoke `afterComponentInitialize` and store its result (the `Promise`) in the `initPromise` response to `await` it later.\n- We invoke `beforeComponentDestroy` to simulate the user navigating away and framework destroying the component.\n- We `await initPromise` to simulate the server response arrival.\n- We assert the the `error` method was not called.\n\n## Exercise\n\nFor this lesson's exercise, a delete article process with confirmation has been added to the `ArticleComponent` in the form of three methods (see in the code playground below). That implements a requirement to get the user's confirmation before actually deleting an article. The process steps look like this:\n\n- The user clicks the Delete button on the article.\n- A dialog appears with a disclaimer and two buttons - Confirm and Cancel. \"Are you sure you want to delete the article ....?\"\n- The user might confirm and delete the article.\n- The user might cancel and back out.\n\nFind and finish the tests in `spec/article-component.spec.mjs` in the code playground below. They are in a nested `describe` (`fdescribe`) test suite. That approach allows for some logical grouping of tests. The nested `describe` is actually a `fdescribe` which tells Jasmine to focus on this `describe` and only perform its tests. This is so that the rest of the tests (8) do not clutter the exercise ones. Feel free to leave it as is or replace it with a `describe` at any time.\n\nThere are a few tests for this exercise:\n\n- When `onDeleteArticle` is invoked the dialog should be shown i.e. `showDeleteArticleConfirmationDialog === true`.\n- When `onDeleteArticle` gets invoked, and then the `onDeleteArticleCancel` is invoked, a call to the `delete` method on the API is NOT made. And the dialog (`showDeleteArticleConfirmationDialog`) should be hidden.\n- When `onDeleteArticle` and then the `onDeleteArticleConfirm` get invoked, a call to the `delete` method on the API is made. And the `info` method on the `userMessenger` should have been called with a specific message.\n\nIf stuck see, the hints below.","mdHtml":"<h2>Breakdown - ArticleComponent</h2>\n<p>Looking at the <code>src/article.component.mjs</code>:</p>\n<ul>\n<li>\n<pre><code class=\"language-js\">export class ArticleComponent {\n  articleId; // or props.articleId\n\n  article;\n  loading;\n  destroyed;\n  //...\n}\n</code></pre>\n<p>We start by declaring the class of the component and declaring some properties in it:</p>\n<ul>\n<li>The <code>articleId</code> is the id of the article the component is to display. This is expected to be an input (or prop) i.e. the component relies on it being there to be able to do its job. Examples: <a href=\"https://angular.io/guide/inputs-outputs#sending-data-to-a-child-component\">Angular Input</a>, <a href=\"https://reactjs.org/docs/components-and-props.html#rendering-a-component\">React prop</a>, <a href=\"https://v3.vuejs.org/guide/component-props.html#passing-static-or-dynamic-props\">Vue prop</a>.</li>\n<li>The <code>article</code> will hold a reference to the article object that is going to be fetched from the <code>ArticleAPI</code>.</li>\n<li>The <code>loading</code> is the property that lets us show/hide a loading spinner to the user to let them know something is afoot.</li>\n<li>The <code>destroyed</code> is the property will become true when the component is being destroyed. It will be used to stop any further processing at that point.</li>\n</ul>\n</li>\n<li>\n<pre><code class=\"language-js\">articleAPI;\nuserMessenger;\n\nconstructor(articleApi, userMessenger) {\n  this.articleAPI = articleApi;\n  this.userMessenger = userMessenger;\n}\n</code></pre>\n<ul>\n<li>The <code>articleAPI</code> is the instance that lets us call the server API endpoint to get the article or delete it.</li>\n<li>The <code>userMessenger</code> is an instance of the <code>UserMessenger</code> class that will show a message to the user. It can be of the <code>info</code> or <code>error</code> category using the correspondingly named method of that class.</li>\n<li>In the <code>constructor</code> we populate the <code>articleAPI</code> and the <code>userMessenger</code> properties with the passed-in instances.</li>\n</ul>\n</li>\n<li>\n<pre><code class=\"language-js\">async afterComponentInitialize() {\n  this.loading = true;\n  try {\n    const article = await this.articleAPI.get(this.articleId);\n    if(!this.destroyed) {\n      this.article = article;\n    }\n  } catch {\n    if(!this.destroyed) {\n      this.userMessenger.error(`Could not fetch article id: &quot;${this.articleId}&quot;. Please try again.`);\n    }\n  }\n  this.loading = false;\n}\n</code></pre>\n<p>This method is a “hook” that will get called by the framework (e.g. Angular or React) after the component initializes and is ready to take the data and display it. It’s an <code>async</code> method that allows us to use <code>await</code> within it.</p>\n<p>The <code>this.loading = true;</code> line sets up the loading state so that a user will see a spinner indicating something is going on in the background.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">try {\n  const article = await this.articleAPI.get(this.articleId);\n  if (!this.destroyed) {\n    this.article = article;\n  }\n}\n</code></pre>\n<p>Wrapping the logic in a <code>try catch</code> to make sure if the api call throws, we catch the error and handle it (handling logic is next).</p>\n<p>The <code>this.articleAPI.get(this.articleId)</code> call is asynchronous (i.e. it returns a <code>Promise</code>) so we <code>await</code> it and get the response in the <code>article</code> local constant.</p>\n<p>If the component has been destroyed there is no point to populate the article property so we skip it. This check is largely not necessary for such a straightforward component logic. It serves to demonstrate the “do not process any more logic after the component has been destroyed” approach which serves to effectively cancel any further calculations and stop potential memory leaks. (<a href=\"https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/#Further-reading\">Memory leaks in JavaScript article</a>)</p>\n<p>In essence, this check is here so we can demo how to test such logic.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">try {\n  // ... skipped\n} catch {\n  if (!this.destroyed) {\n    this.userMessenger.error(`Could not fetch article id: &quot;${this.articleId}&quot;. Please try again.`);\n  }\n}\n</code></pre>\n<p>In the case of an error returned from the server (400 or 500) we expect the <code>Promise</code> will get rejected so we handle that case. Handle it by showing relevant information to the user and potentially how they can resolve this situation.</p>\n<p>Again, this logic is wrapped in a check if the component has been destroyed. This is to handle a case similar to:</p>\n<ul>\n<li>User opens the article.</li>\n<li>Spinner appears.</li>\n<li>Response takes a lot of time, and the spinner stays on.</li>\n<li>User closes the article component (e.g. navigates back).</li>\n<li>Component gets destroyed at this time.</li>\n<li>Response arrives after that and is an error (500).</li>\n<li>Showing an error at this time will be confusing for the user who is in a different context now e.g. the article list page. Hence the check if the component has been destroyed before showing the error.</li>\n</ul>\n</li>\n<li>\n<pre><code class=\"language-js\">beforeComponentDestroy() {\n  this.destroyed = true;\n  this.article = undefined;\n}\n</code></pre>\n<p>This is the “hook” that gets called by the framework when component destruction is about to happen. After this call, the framework (e.g. Angular or React) will remove the component from the DOM and discard it.</p>\n<p>We mark this component instance as <code>destroyed</code> and also discard any <code>article</code> object the component might hold a reference to, thus resetting it.</p>\n</li>\n</ul>\n<h2>Breakdown - tests</h2>\n<p>We’ll test the two “hook” methods. There’s a new challenge for the tests: The “hook” <code>beforeComponentDestroy</code> method changes the behavior of the <code>afterComponentInitialize</code> while the <code>afterComponentInitialize</code> is still being processed.</p>\n<p>Let’s look at <code>spec/article-component.spec.mjs</code>:</p>\n<ul>\n<li>\n<pre><code class=\"language-js\">import { ArticleComponent } from '../__src__/article.component.mjs';\n</code></pre>\n<p>We start by importing the <code>ArticleComponent</code>.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">describe('ArticleComponent', () =&gt; {\n  let component;\n  let articleAPI;\n  let userMessenger;\n</code></pre>\n<p>We define a test suite <code>ArticleComponent</code>.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">let component;\nlet articleAPI;\nlet userMessenger;\n\nbeforeEach(() =&gt; {\n  articleAPI = jasmine.createSpyObj('article API', {\n    get: Promise.resolve({ id: 1, title: 'first', content: 'article' }),\n  });\n  userMessenger = jasmine.createSpyObj('userMessenger', ['info', 'error']);\n  component = new ArticleComponent(articleAPI, userMessenger);\n});\n</code></pre>\n<p>We define some variables that will be available for every test. They get reset before each test in the <code>beforeEach</code> Jasmine “hook”.</p>\n<ul>\n<li>The <code>articleAPI</code> uses a different <code>createSpyObj</code> method overload which allows us to define the default response. In this case, we instruct Jasmine to create a spy for the <code>get</code> method of the <code>ArticleAPI</code> instance and return a Promise resolving to an article.</li>\n<li>The <code>userMessenger</code> is also a spy object, and it defines multiple methods for Jasmine to spy on `[‘info’, ‘error’].</li>\n<li>The <code>component</code> is reset to a new instance before every test, making each test separate and independent of the rest.</li>\n</ul>\n</li>\n</ul>\n<h3>Test case <code>when initialized it should call the articleAPI get and assign the result to the article property</code></h3>\n<pre><code class=\"language-js\">it(`when initialized it should call the articleAPI get and assign the result to the article property`, async () =&gt; {\n  // arrange\n  component.articleId = 1;\n  // act\n  await component.afterComponentInitialize();\n  // assert\n  expect(articleAPI.get).toHaveBeenCalledOnceWith(1);\n  expect(component.article).toEqual(jasmine.objectContaining({ id: 1 }));\n});\n</code></pre>\n<p>In the above test case, we’ll make sure the article is assigned to the <code>article</code> property of the component when the server response arrives:</p>\n<ul>\n<li>Provide the component with an article id.</li>\n<li>Call the <code>afterComponentInitialize</code> method, simulating what a framework will do.</li>\n<li>Make sure that <code>get</code> was called with the expected <code>id</code>, and the article returned is an object that contains the <code>id: 1</code> in it.\n<ul>\n<li>The <code>id: 1, title: ...</code> was set in the default response for <code>get</code> in the <code>beforeEach</code> above and not in the test itself.</li>\n</ul>\n</li>\n</ul>\n<h3>Test case <code>when initialized it should call the articleAPI get and inform user upon article fetch failed</code></h3>\n<pre><code class=\"language-js\">it(`when initialized it should call the articleAPI get and inform user upon article fetch failed`, async () =&gt; {\n  // arrange\n  component.articleId = 1;\n  articleAPI.get.and.returnValue(Promise.reject('error'));\n  // act\n  await component.afterComponentInitialize();\n  // assert\n  expect(userMessenger.error).toHaveBeenCalledOnceWith('Could not fetch article id: &quot;1&quot;. Please try again.');\n});\n</code></pre>\n<p>In the above test case, we’ll make sure that the user gets notified of an error via the <code>userMessenger.error</code> method when an error happens i.e. the response is 4xx or 5xx:</p>\n<ul>\n<li>Provide the component with an article <code>id</code>.</li>\n<li>Provide <code>articleAPI.get</code> a promise that is rejected. That is the failing scenario.</li>\n<li>Call the <code>returnValue</code>.</li>\n<li>Assert that the <code>error</code> method of <code>userMessenger</code> has been called as expected.</li>\n</ul>\n<h3>Test case <code>when initialized it should set loading to true and back to false after the article response arrives</code></h3>\n<pre><code class=\"language-js\">it(`when initialized it should set loading to true and back to false after the article response arrives`, async () =&gt; {\n  // arrange\n  articleAPI.get.and.returnValue(Promise.resolve({ id: 1 }));\n  component.articleId = 1;\n  // act\n  const initPromise = component.afterComponentInitialize();\n  // assert\n  expect(component.loading).toBe(true);\n  await initPromise;\n  expect(component.loading).toBe(false);\n});\n</code></pre>\n<p>In the above test case, we’ll make sure the <code>loading</code> is <code>true</code> while the component waits for the article to arrive, and then it turns to <code>false</code>:</p>\n<ul>\n<li>We start by providing the return value <code>Promise.resolve({id: 1})</code>. Since it’s valuable for the outcome of the test, we explicitly provide it. It’s valuable because if the Promise is rejected the test will fail.</li>\n<li>We need to control when the <code>Promise</code> is resolved i.e. when the server responds so that we’re able to verify the <code>loading</code> is <code>true</code> in the meantime.</li>\n<li>We store the promise in <code>initPromise</code> local constant and not <code>await</code> it until we’ve asserted that the value of <code>loading</code> is <code>true</code>.</li>\n<li>We assert the <code>loading</code> is <code>true</code></li>\n<li>We <code>await initPromise</code> simulating the wait until the response arrives and assert the <code>loading</code> is now <code>false</code>.</li>\n</ul>\n<h3>Test case <code>when initialized it should set loading to true and back to false even after article fetch fails</code></h3>\n<pre><code class=\"language-js\">it(`when initialized it should set loading to true and back to false even after article fetch fails`, async () =&gt; {\n  // arrange\n  articleAPI.get.and.returnValue(Promise.reject({ message: 'error' }));\n  component.articleId = 1;\n  // act\n  const initPromise = component.afterComponentInitialize();\n  // assert\n  expect(component.loading).toBe(true);\n  await initPromise;\n  expect(component.loading).toBe(false);\n});\n</code></pre>\n<p>In the above test case, we’ll make sure that <code>loading</code> behaves correctly in case of an error. So it turns <code>true</code> while waiting for the response and <code>false</code> when the response arrives.</p>\n<ul>\n<li>We start providing a rejected <code>Promise</code> as the <code>articleAPI.get</code> response.</li>\n<li>We store the <code>Promise</code> in the <code>initPromise</code> constant and not <code>await</code> it.</li>\n<li>We assert the <code>loading</code> is <code>true</code> while waiting for the response.</li>\n<li>We <code>await initPromise</code> to simulate the response arriving.</li>\n<li>We assert the <code>loading</code> is now <code>false</code> even though an error happened.</li>\n</ul>\n<h3>Test case <code>when destroyed it should not set the article property</code></h3>\n<pre><code class=\"language-js\">it(`when destroyed it should not set the article property`, async () =&gt; {\n  // arrange\n  component.articleId = 1;\n  articleAPI.get.and.returnValue(\n    Promise.resolve({ id: 1, title: 'will not be shown to user because the component was destroyed' })\n  );\n  const initPromise = component.afterComponentInitialize();\n  // act\n  component.beforeComponentDestroy();\n  await initPromise;\n  // assert\n  expect(component.article).toBeUndefined();\n});\n</code></pre>\n<p>In the above test case, we’ll make sure that (1) the <code>article</code> property does not get populated in a (2) destroyed component. That simulates a case where the user decided to navigate away from the current page, and while the new page intent is getting processed by the routing logic, the article response arrives. In that case, we don’t want to show the article info for a split second and then close it (it might cause a flash of content issue).</p>\n<ul>\n<li>We start by providing a good response by the <code>articleAPI.get</code>.</li>\n<li>We call the <code>afterComponentInitialize</code> and store its result, the <code>initPromise</code> in a constant, and not <code>await</code> it. That allows us to destroy the component before the response arrives, simulating the second part (2) of the condition above.</li>\n<li>We call the <code>beforeComponentDestroy</code> to simulate the first part (1) of the condition above.</li>\n<li>We <code>await initPromise</code> simulating the response arriving.</li>\n<li>We assert that the <code>article</code> property is indeed <code>undefined</code> as expected.</li>\n</ul>\n<h3>Test case <code>when destroyed it should not inform user upon article fetch failed</code></h3>\n<pre><code class=\"language-js\">it(`when destroyed it should not inform user upon article fetch failed`, async () =&gt; {\n  // arrange\n  component.articleId = 1;\n  articleAPI.get.and.returnValue(Promise.reject('error'));\n  const initPromise = component.afterComponentInitialize();\n  // act\n  component.beforeComponentDestroy();\n  await initPromise;\n  // assert\n  expect(userMessenger.error).not.toHaveBeenCalledOnceWith('Could not fetch article id: &quot;1&quot;. Please try again.');\n});\n</code></pre>\n<p>In the above test case, we’ll make sure that the user is not notified of an error after they’ve decided to navigate away from this component e.g. if the response took too long and timed out.</p>\n<ul>\n<li>We provide a rejected <code>Promise</code> to the <code>articleAPI.get</code> simulating the timed-out response.</li>\n<li>We invoke <code>afterComponentInitialize</code> and store its result (the <code>Promise</code>) in the <code>initPromise</code> response to <code>await</code> it later.</li>\n<li>We invoke <code>beforeComponentDestroy</code> to simulate the user navigating away and framework destroying the component.</li>\n<li>We <code>await initPromise</code> to simulate the server response arrival.</li>\n<li>We assert the the <code>error</code> method was not called.</li>\n</ul>\n<h2>Exercise</h2>\n<p>For this lesson’s exercise, a delete article process with confirmation has been added to the <code>ArticleComponent</code> in the form of three methods (see in the code playground below). That implements a requirement to get the user’s confirmation before actually deleting an article. The process steps look like this:</p>\n<ul>\n<li>The user clicks the Delete button on the article.</li>\n<li>A dialog appears with a disclaimer and two buttons - Confirm and Cancel. “Are you sure you want to delete the article …?”</li>\n<li>The user might confirm and delete the article.</li>\n<li>The user might cancel and back out.</li>\n</ul>\n<p>Find and finish the tests in <code>spec/article-component.spec.mjs</code> in the code playground below. They are in a nested <code>describe</code> (<code>fdescribe</code>) test suite. That approach allows for some logical grouping of tests. The nested <code>describe</code> is actually a <code>fdescribe</code> which tells Jasmine to focus on this <code>describe</code> and only perform its tests. This is so that the rest of the tests (8) do not clutter the exercise ones. Feel free to leave it as is or replace it with a <code>describe</code> at any time.</p>\n<p>There are a few tests for this exercise:</p>\n<ul>\n<li>When <code>onDeleteArticle</code> is invoked the dialog should be shown i.e. <code>showDeleteArticleConfirmationDialog === true</code>.</li>\n<li>When <code>onDeleteArticle</code> gets invoked, and then the <code>onDeleteArticleCancel</code> is invoked, a call to the <code>delete</code> method on the API is NOT made. And the dialog (<code>showDeleteArticleConfirmationDialog</code>) should be hidden.</li>\n<li>When <code>onDeleteArticle</code> and then the <code>onDeleteArticleConfirm</code> get invoked, a call to the <code>delete</code> method on the API is made. And the <code>info</code> method on the <code>userMessenger</code> should have been called with a specific message.</li>\n</ul>\n<p>If stuck see, the hints below.</p>\n","cursorPosition":0,"comp_id":"OsUca0at3QToM2_LXxzFD"},"iteration":3,"hash":3},{"type":"WebpackBin","mode":"view","content":{"version":4,"theme":"default","showLineNumbers":true,"showConsole":false,"hideResultOutput":true,"hideOutputUrl":true,"hideCodeView":false,"loaders":{"babel":{"title":"React","config":{"es2015":true,"react":true},"enabled":true},"dart":{"title":"Dart","config":{"dart":true},"enabled":false},"ts-react":{"title":"Typescript React","config":{"ts-react":true},"enabled":false},"elm":{"title":"Elm","config":{"elm":true},"enabled":false},"vue":{"title":"Vue.js","config":{"vue":true},"enabled":false},"gojs-react":{"title":"GoJS React","config":{"gojs-react":true},"enabled":false}},"npmPackages":{"react":"15.6.1","react-dom":"15.6.1"},"outputHeight":300,"selectedApiKeys":{},"selectedEnvVars":{},"outputLayout":"desktop","codeContents":{"module":"/","id":0,"selectedId":9347825474426,"maxId":4143309580768,"children":[{"id":4688759501787,"module":"spec","leaf":false,"collapsed":true,"children":[{"id":1121696285684,"module":"support","leaf":false,"collapsed":true,"children":[{"id":6598372721145,"module":"jasmine-browser.js","leaf":true,"data":{"content":"const specReporter = require('jasmine-spec-reporter').SpecReporter\n\nmodule.exports = {\n  srcDir: \"src\",\n  srcFiles: [\n    \"**/*.?(m)js\"\n  ],\n  specDir: \"spec\",\n  specFiles: [\n    \"**/*[sS]pec.?(m)js\"\n  ],\n  helpers: [\n    \"helpers/**/*.?(m)js\"\n  ],\n  random: false,\n  stopSpecOnExpectationFailure: false,\n  browser: {\n    name: \"headlessChrome\"\n  },\n  reporters: [new specReporter()]\n}\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":1121696285684}],"parentId":4688759501787},{"id":9347825474426,"module":"article-component.spec.mjs","leaf":true,"data":{"content":"import { ArticleComponent } from '../__src__/article.component.mjs';\n\ndescribe('ArticleComponent', () => {\n  let component;\n  let articleAPI;\n  let userMessenger;\n\n  beforeEach(() => {\n    articleAPI = jasmine.createSpyObj('article API', {\n      get: Promise.resolve({ id: 1, title: 'first', content: 'article' }),\n      delete: Promise.resolve(),\n    });\n    userMessenger = jasmine.createSpyObj('userMessenger', ['info', 'error']);\n    component = new ArticleComponent(articleAPI, userMessenger);\n  });\n\n  it(`when initialized it should call the articleAPI get and assign the result to the article property`, async () => {\n    // arrange\n    component.articleId = 1;\n    // act\n    await component.afterComponentInitialize();\n    // assert\n    expect(articleAPI.get).toHaveBeenCalledOnceWith(1);\n    expect(component.article).toEqual(jasmine.objectContaining({ id: 1 }));\n  });\n\n  it(`when initialized it should call the articleAPI get and inform user upon article fetch failed`, async () => {\n    // arrange\n    component.articleId = 1;\n    articleAPI.get.and.returnValue(Promise.reject('error'));\n    // act\n    await component.afterComponentInitialize();\n    // assert\n    expect(userMessenger.error).toHaveBeenCalledOnceWith('Could not fetch article id: \"1\". Please try again.');\n  });\n\n  it(`when initialized it should set loading to true and back to false after the article response arrives`, async () => {\n    // arrange\n    articleAPI.get.and.returnValue(Promise.resolve({ id: 1 }));\n    component.articleId = 1;\n    // act\n    const initPromise = component.afterComponentInitialize();\n    // assert\n    expect(component.loading).toBe(true);\n    await initPromise;\n    expect(component.loading).toBe(false);\n  });\n\n  it(`when initialized it should set loading to true and back to false even after article fetch fails`, async () => {\n    // arrange\n    articleAPI.get.and.returnValue(Promise.reject({ message: 'error' }));\n    component.articleId = 1;\n    // act\n    const initPromise = component.afterComponentInitialize();\n    // assert\n    expect(component.loading).toBe(true);\n    await initPromise;\n    expect(component.loading).toBe(false);\n  });\n\n  it(`when destroyed it should not set the article property`, async () => {\n    // arrange\n    component.articleId = 1;\n    articleAPI.get.and.returnValue(\n      Promise.resolve({ id: 1, title: 'will not be shown to user because the component was destroyed' })\n    );\n    const initPromise = component.afterComponentInitialize();\n    // act\n    component.beforeComponentDestroy();\n    await initPromise;\n    // assert\n    expect(component.article).toBeUndefined();\n  });\n\n  it(`when destroyed it should not inform user upon article fetch failed`, async () => {\n    // arrange\n    component.articleId = 1;\n    articleAPI.get.and.returnValue(Promise.reject('error'));\n    const initPromise = component.afterComponentInitialize();\n    // act\n    component.beforeComponentDestroy();\n    await initPromise;\n    // assert\n    expect(userMessenger.error).not.toHaveBeenCalledOnceWith('Could not fetch article id: \"1\". Please try again.');\n  });\n\n  fdescribe('article delete', () => {\n    it(`when onArticleDelete invoked it should show the article delete dialog`, () => {\n      pending('test user seeing the delete dialog - showDeleteArticleConfirmationDialog');\n      // arrange\n      // act\n      // assert\n    });\n\n    it(`when onArticleDelete invoked and then cancelled it should hide the dialog`, () => {\n      pending('test user closing the delete dialog on cancel - showDeleteArticleConfirmationDialog');\n      // arrange\n      // act\n      // assert\n    });\n\n    it(`when onArticleDelete invoked and then confirmed it should invoke the article API delete`, async () => {\n      pending('test the full delete flow open dialog and confirm');\n      // arrange\n      // act\n      // assert\n    });\n  });\n});\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":4688759501787}],"parentId":0},{"id":4143309580768,"module":"src","leaf":false,"collapsed":true,"children":[{"id":2541059396112,"module":"article-api.mjs","leaf":true,"data":{"content":"export class ArticleAPI {\n  get(id) {\n    // make a GET /api/article/:id request (XMLHttpRequest/fetch/axios)\n    // and return a promise\n  }\n\n  delete(id) {\n    // make a DELETE /api/article/:id request (XMLHttpRequest/fetch/axios)\n    // and return a promise\n  }\n\n  create(title, content) {\n    // make a POST /api/article request (XMLHttpRequest/fetch/axios)\n    // and return a promise\n  }\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":4143309580768},{"id":1861056242165,"module":"article.component.mjs","leaf":true,"data":{"content":"export class ArticleComponent {\n  articleId; // or props.articleId\n\n  article;\n  loading;\n  destroyed;\n\n  articleAPI;\n  userMessenger;\n\n  showDeleteArticleConfirmationDialog;\n\n  constructor(articleApi, userMessenger) {\n    this.articleAPI = articleApi;\n    this.userMessenger = userMessenger;\n  }\n\n  async afterComponentInitialize() {\n    this.loading = true;\n    try {\n      const article = await this.articleAPI.get(this.articleId);\n      if(!this.destroyed) {\n        this.article = article;\n      }\n    } catch {\n      if(!this.destroyed) {\n        this.userMessenger.error(`Could not fetch article id: \"${this.articleId}\". Please try again.`);\n      }\n    }\n    this.loading = false;\n  }\n\n  beforeComponentDestroy() {\n    this.destroyed = true;\n    this.article = undefined;\n\n    this.showDeleteArticleConfirmationDialog = false;\n  }\n\n  onDeleteArticle() {\n    this.showDeleteArticleConfirmationDialog = true;\n  }\n\n  async onDeleteArticleConfirm() {\n    this.showDeleteArticleConfirmationDialog = false;\n    await this.articleAPI.delete(this.articleId);\n    this.userMessenger.info('Article successfully deleted');\n  }\n\n  onDeleteArticleCancel() {\n    this.showDeleteArticleConfirmationDialog = false;\n  }\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":4143309580768},{"id":7479731821561,"module":"user-messanger.mjs","leaf":true,"data":{"content":"export class UserMessenger {\n    info() {\n        // show an info message (e.g. a snack)\n    }\n    error() {\n        // show an error message (e.g. a snack)\n    }\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":4143309580768}],"parentId":0}],"importedGithubPath":"https://github.com/gparlakov/jasmine-educative/tree/main/3.3.spa-component-exercise"},"dockerJob":{"key":"MAg0aPm2NgdrpUzSEzwM0","name":"Run jasmine-browser-runner console","inputFileName":"index.js","runScript":"cp -r /usercode/** .","ports":"3000","startScript":"cd /usr/local/educative/unit-testing-course && \nnpx nodemon -w /usercode --exec \"cp -r /usercode/** . && npx jasmine-browser-runner runSpecs\"","jobType":"Live","forceRelaunchOnRun":false,"forceRelaunchOnCompChange":true,"runInLiveContainer":true},"caption":"Exercise","comp_id":"PaDtT02PM3hNBomW2zr4t","isCopied":true},"iteration":17,"hash":4},{"type":"SpoilerEditor","mode":"edit","content":{"version":"3.0","text":"```js\nit(`when onArticleDelete invoked it should show the article delete dialog`, () => {\n  // arrange\n  // act\n  component.onDeleteArticle();\n  // assert\n  expect(component.showDeleteArticleConfirmationDialog).toBe(true);\n});\n```","mdHtml":"<pre><code class=\"language-js\">it(`when onArticleDelete invoked it should show the article delete dialog`, () =&gt; {\n  // arrange\n  // act\n  component.onDeleteArticle();\n  // assert\n  expect(component.showDeleteArticleConfirmationDialog).toBe(true);\n});\n</code></pre>\n","showHintText":"Show Hint for `when onArticleDelete invoked it should show the article delete dialog`","hideHintText":"Hide Hint","showIcon":true,"comp_id":"f6ImJynZqBhc9lurSQ0Eg"},"iteration":6,"hash":5},{"type":"SpoilerEditor","mode":"edit","content":{"version":"3.0","text":"```js\nit(`when onArticleDelete invoked and then cancelled it should hide the dialog`, () => {\n  // arrange\n  component.onDeleteArticle();\n  // act\n  component.onDeleteArticleCancel();\n  // assert\n  expect(component.showDeleteArticleConfirmationDialog).toBe(false);\n});\n```","mdHtml":"<pre><code class=\"language-js\">it(`when onArticleDelete invoked and then cancelled it should hide the dialog`, () =&gt; {\n  // arrange\n  component.onDeleteArticle();\n  // act\n  component.onDeleteArticleCancel();\n  // assert\n  expect(component.showDeleteArticleConfirmationDialog).toBe(false);\n});\n</code></pre>\n","showHintText":"Show Hint for `when onArticleDelete invoked and then canceled it should hide the dialog`","hideHintText":"Hide Hint","showIcon":true,"comp_id":"7wBJV3ROGSzBbT7HM7hrs"},"iteration":6,"hash":6},{"type":"SpoilerEditor","mode":"edit","content":{"version":"3.0","text":"```js\nit(`when onArticleDelete invoked and then confirmed it should invoke the article API delete`, async () => {\n  // arrange\n  component.articleId = 1;\n  component.onDeleteArticle();\n  articleAPI.delete.and.returnValue(Promise.resolve());\n  // act\n  await component.onDeleteArticleConfirm();\n  // assert\n  expect(component.showDeleteArticleConfirmationDialog).toBe(false);\n  expect(articleAPI.delete).toHaveBeenCalledOnceWith(1);\n  expect(userMessenger.info).toHaveBeenCalledOnceWith('Article successfully deleted');\n});\n```","mdHtml":"<pre><code class=\"language-js\">it(`when onArticleDelete invoked and then confirmed it should invoke the article API delete`, async () =&gt; {\n  // arrange\n  component.articleId = 1;\n  component.onDeleteArticle();\n  articleAPI.delete.and.returnValue(Promise.resolve());\n  // act\n  await component.onDeleteArticleConfirm();\n  // assert\n  expect(component.showDeleteArticleConfirmationDialog).toBe(false);\n  expect(articleAPI.delete).toHaveBeenCalledOnceWith(1);\n  expect(userMessenger.info).toHaveBeenCalledOnceWith('Article successfully deleted');\n});\n</code></pre>\n","showHintText":"Show Hint for `when onArticleDelete invoked and then confirmed it should invoke the article API delete`","hideHintText":"Hide Hint","showIcon":true,"comp_id":"e1zt8pHW0PkfnBvZ4PpHK"},"iteration":7,"hash":7,"saveVersion":1}],"summary":{"title":"How to Test Single Page App Components","description":"In this lesson, we'll focus on some of the specifics of a Single Page App component and its testing like lifecycle hooks and event handlers. \n","tags":["SPA","lifecycle hooks","unit test"]}}