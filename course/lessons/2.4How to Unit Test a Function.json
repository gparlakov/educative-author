{"components":[{"type":"MarkdownEditor","content":{"version":"2.0","text":"## FlatMap tests\n\nLet's try and write the function and tests from the previous lesson using Jasmine.\n\nWe'd like to have the spec file right next to the source file. That way the spec is separated from the production code that we'll eventually ship, but still close at hand.\n\nTo that end we have:\n\n- `src/flat-map.js` - the implementation\n- `src/flat-map.spec.js` - the spec\n\n## Run\n\nRun the code playground below.","mdHtml":"<h2>FlatMap tests</h2>\n<p>Let’s try and write the function and tests from the previous lesson using Jasmine.</p>\n<p>We’d like to have the spec file right next to the source file. That way the spec is separated from the production code that we’ll eventually ship, but still close at hand.</p>\n<p>To that end we have:</p>\n<ul>\n<li><code>src/flat-map.js</code> - the implementation</li>\n<li><code>src/flat-map.spec.js</code> - the spec</li>\n</ul>\n<h2>Run</h2>\n<p>Run the code playground below.</p>\n","cursorPosition":{"line":0,"ch":0},"comp_id":"fDZEseg0SFt2VIW5Rz4B7"},"iteration":2,"hash":1,"saveVersion":14},{"type":"WebpackBin","mode":"edit","content":{"version":5,"theme":"default","showLineNumbers":true,"showConsole":false,"hideResultOutput":true,"hideOutputUrl":true,"hideCodeView":false,"loaders":{"babel":{"title":"React","config":{"es2015":true,"react":true},"enabled":true},"dart":{"title":"Dart","config":{"dart":true},"enabled":false},"ts-react":{"title":"Typescript React","config":{"ts-react":true},"enabled":false},"elm":{"title":"Elm","config":{"elm":true},"enabled":false},"vue":{"title":"Vue.js","config":{"vue":true},"enabled":false},"gojs-react":{"title":"GoJS React","config":{"gojs-react":true},"enabled":false}},"npmPackages":{"react":"15.6.1","react-dom":"15.6.1"},"outputHeight":300,"selectedApiKeys":{},"selectedEnvVars":{},"outputLayout":"desktop","codeContents":{"module":"/","id":0,"selectedId":7235402230024,"maxId":8741168015836,"children":[{"id":2225696041157,"module":"spec","leaf":false,"collapsed":true,"children":[{"id":4954534385011,"module":"support","leaf":false,"collapsed":true,"children":[{"id":7348276632337,"module":"jasmine.config.js","leaf":true,"data":{"content":"const SpecReporter = require('jasmine-spec-reporter').SpecReporter\r\n\r\njasmine.getEnv().clearReporters();\r\n\r\njasmine.getEnv().addReporter(\r\n  new SpecReporter({\r\n    spec: {\r\n      displayPending: true,\r\n    },\r\n  })\r\n)\r\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":4954534385011},{"id":4347693773754,"module":"jasmine.json","leaf":true,"data":{"content":"{\n  \"spec_dir\": \"src\",\n  \"spec_files\": [\n    \"**/*[sS]pec.js\"\n  ],\n  \"helpers\": [\n    \"../spec/support/jasmine.config.js\"\n  ],\n  \"stopSpecOnExpectationFailure\": false,\n  \"random\": false\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":4954534385011}],"parentId":2225696041157}],"parentId":0},{"id":9886121429624,"module":"src","leaf":false,"collapsed":true,"children":[{"id":5199987253004,"module":"flat-map.js","leaf":true,"data":{"content":"Array.prototype.flatMap = function(cb) {\r\n  return this.map(cb).reduce((acc, n) => acc.concat(n), []);\r\n}","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":9886121429624},{"id":7235402230024,"module":"flat-map.spec.js","leaf":true,"data":{"content":"// load the polyfill\r\nrequire('./flat-map');\r\n\r\ndescribe(\"flatMap polyfill\", () => {\r\n    it(\"test case 1\", () => {\r\n        const numbers = [1, 2, 3, 4];\r\n        const actual = numbers.flatMap(x => [x, x * 2]);\r\n        expect(actual).toEqual([1, 2, 2, 4, 3, 6, 4, 8]);\r\n    })\r\n\r\n    it(\"test case 2\", () => {\r\n        const strings = [\"it's Sunny in\", \"\", \"California always\"];\r\n        const actual = strings.flatMap(x => x.split(\" \"));\r\n        expect(actual).toEqual([\"it's\", \"Sunny\", \"in\", \"\", \"California\", \"always\"]);\r\n    })\r\n\r\n    it(\"test case 3\", () => {\r\n        const numbers2 = [1, 2, 3, 4];\r\n        const actual = numbers2.flatMap(x => [x * 2]);\r\n        expect(actual).toEqual([2, 4, 6, 8]);\r\n    })\r\n\r\n    it(\"test case 4\", () => {\r\n        const actual = [1, 2, 3, 4].flatMap(x => [[x * 2]]);\r\n        expect(actual).toEqual([[2], [4], [6], [8]]);\r\n    })\r\n})\r\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":9886121429624}],"parentId":0}],"importedGithubPath":"https://github.com/gparlakov/jasmine-educative/tree/main/jasmine-standalone"},"dockerJob":{"key":"7IgoXRRQCavQ48Yy3YCL0","name":"live Jasmine","inputFileName":"src/main.ts","runScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec && cp -r /usercode/** .","ports":"9876","startScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec &&  cp -r /usercode/** . && node_modules/.bin/nodemon -w ../unit-testing-course/ ./node_modules/.bin/jasmine","jobType":"Live","forceRelaunchOnCompChange":true,"runInLiveContainer":true},"comp_id":"LD-j_A6uCs8lBbcYhhCL2"},"iteration":0,"hash":5,"saveVersion":4},{"type":"MarkdownEditor","mode":"edit","content":{"version":"2.0","text":"## Breakdown\n\n- The file `src/flat-map.js` contains our code implementing the flat map poly-fill:\n\n  - In a single line it invokes the `map` function that comes from `Array.prototype`.\n  - Then takes the result of that, which is an array, and invokes its `reduce` function (_we refer to a function attached to an object as a method_).\n    - The `reduce` method will take an accumulator `acc` which will be passed in along with each member of the array, and the result of the callback `(acc, n) => acc.concat(n)` will be stored in the `acc` reference and then passed in for the next iteration.\n    - In short, it `reduces` an array to a single value.\n\n- The file `src/flat-map.spec.js` contains the test cases.\n  > Notice the pattern - **test file name** is the **production file** name + **spec.js**. This is a generally accepted convention to make large projects manageable.\n\n## Test case 1\n\n1. Test confirming that `flatMap` can take arrays of **multiple items** and flat them out to a single array. In this case we have the `flatMap` callback returning arrays of length 2 `x => [x, x*2]` so from our input of `[1, 2, 3, 4]` we'll get:\n   - 1 will yield `[1, 2]`.\n   - 2 will yield `[2, 4]`.\n   - 3 will yield `[3, 6]`.\n   - 4 will yield `[4, 8]`.\n   - Flattening those four arrays should yield one array of `[1, 2, 2, 4, 3, 6, 4, 8]`.\n2. The test has\n\n- An `input` of `const numbers = [1, 2, 3, 4];`.\n- An `actual` of `const actual = numbers.flatMap(x => [x, x * 2]);`.\n- An `expectation` of `expect(actual).toEqual([1, 2, 2, 4, 3, 6, 4, 8]);` where the expected result to check against is inline.\n\n## Test case 2\n\n1. Test confirming that `flatMap` can take arrays of **variable length** strings and flat them out to a single array. In this case we have the `flatMap` callback `x => x.split(\" \")` returning arrays of variable length from the input of `[\"it's Sunny in\", \"\", \"California\"]` we'll get:\n   - `\"it's Sunny in\"` will yield `[\"it's\", \"Sunny\", \"in\"]` of length 3.\n   - `\"\"` will yield `[\"\"]` of length 1.\n   - `\"California always\"` will yield `[\"California\", \"always\"]` of length 2.\n   - flattening those 3 arrays should yield one array of `[\"it's\", \"Sunny\", \"in\", \"\", \"California always\"]`.\n2. The test has:\n\n- An `input` of `const strings = [\"it's Sunny in\", \"\", \"California always\"];`.\n- An `actual` of `const actual = strings.flatMap(x => x.split(\" \"));`.\n- An `expectation` of `expect(actual).toEqual([\"it's\", \"Sunny\", \"in\", \"\", \"California always\"]);` where the expected result to check against is inline.\n\n## Test case 3\n\n1. Test confirming that `flatMap` can take arrays of **length 1** and flat them out to a single array. In this case we have the `flatMap` callback `x => [x * 2]` returning arrays of length 1 from the input of `[1, 2, 3, 4]` we'll get:\n   - `1` -> `[2]`.\n   - `2` -> `[4]`.\n   - `3` -> `[6]`.\n   - `4` -> `[8]`.\n   - Flattening those 4 arrays should yield one of `[2, 4, 6, 8]`.\n2. The test has:\n\n- An `input` of `const numbers2 = [1, 2, 3, 4];`.\n- An `actual` of `const actual = numbers2.flatMap(x => [x * 2]);`.\n- An `expectation` of `expect(actual).toEqual([2, 4, 6, 8]);` where the expected result to check against is inline.\n\n## Test case 4\n\n1. Test confirming that `flatMap` can take **arrays of arrays** and flat them **one level**. In this case we have the `flatMap` callback `x => [[x * 2]]` returning arrays of array from the input of `[1, 2, 3, 4]` we'll get:\n   - `1` -> `[[2]]`.\n   - `2` -> `[[4]]`.\n   - `3` -> `[[6]]`.\n   - `4` -> `[[8]]`.\n   - Flattening those 4 arrays should yield one of `[[2], [4], [6], [8]]`.\n2. The test has:\n\n- An `input` and an `actual` of `const actual = [1, 2, 3, 4].flatMap(x => [[x * 2]]);`.\n- An `expectation` of `expect(actual).toEqual([[2], [4], [6], [8]]);` where the expected result to check against is inline,\n\n## Experiment\n\n- Change the input and see how tests change.\n  - For example - in the test case 2, replace `const strings = [\"it's Sunny in\", \"\", \"California always\"];` with `const strings = [\"it's Sunny in\", \"\", \"California\"];`.\n- Change implementation and see how tests fail: Replace `return this.map(cb).reduce((acc, n) => acc.concat(n), []);`with `return this.map(cb).reduce((acc, n) => acc.concat(n), [1]);` adding the `1` in the array in `reduce`.\n\n## Naming the tests\n\nThe tests are presently named `test case 1` `test case 2`... That will be a problem for a reader of the tests. They lack the mental model of the issue at hand that the author does. That is if I read these test cases and don't already know what the function does and why I will have a hard time understanding why the tests verify what they do.\n\nIn other words, picking a **descriptive** name for each test case would benefit greatly the understanding of future **readers** _(in time that group will probably include the author)_.\n\nThe renamed tests:\n\n- The \"test case 1\" becomes \"should flat arrays of length 2\".\n- The \"test case 2\" becomes \"should flat arrays of variable length\".\n- The \"test case 3\" becomes \"should flat arrays of length 1\".\n- The \"test case 4\" becomes \"should only flat one-level-deep nested arrays of arrays\".\n","mdHtml":"<h2>Breakdown</h2>\n<ul>\n<li>\n<p>The file <code>src/flat-map.js</code> contains our code implementing the flat map poly-fill:</p>\n<ul>\n<li>In a single line it invokes the <code>map</code> function that comes from <code>Array.prototype</code>.</li>\n<li>Then takes the result of that, which is an array, and invokes its <code>reduce</code> function (<em>we refer to a function attached to an object as a method</em>).\n<ul>\n<li>The <code>reduce</code> method will take an accumulator <code>acc</code> which will be passed in along with each member of the array, and the result of the callback <code>(acc, n) =&gt; acc.concat(n)</code> will be stored in the <code>acc</code> reference and then passed in for the next iteration.</li>\n<li>In short, it <code>reduces</code> an array to a single value.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>The file <code>src/flat-map.spec.js</code> contains the test cases.</p>\n<blockquote>\n<p>Notice the pattern - <strong>test file name</strong> is the <strong>production file</strong> name + <strong>spec.js</strong>. This is a generally accepted convention to make large projects manageable.</p>\n</blockquote>\n</li>\n</ul>\n<h2>Test case 1</h2>\n<ol>\n<li>Test confirming that <code>flatMap</code> can take arrays of <strong>multiple items</strong> and flat them out to a single array. In this case we have the <code>flatMap</code> callback returning arrays of length 2 <code>x =&gt; [x, x*2]</code> so from our input of <code>[1, 2, 3, 4]</code> we’ll get:\n<ul>\n<li>1 will yield <code>[1, 2]</code>.</li>\n<li>2 will yield <code>[2, 4]</code>.</li>\n<li>3 will yield <code>[3, 6]</code>.</li>\n<li>4 will yield <code>[4, 8]</code>.</li>\n<li>Flattening those four arrays should yield one array of <code>[1, 2, 2, 4, 3, 6, 4, 8]</code>.</li>\n</ul>\n</li>\n<li>The test has</li>\n</ol>\n<ul>\n<li>An <code>input</code> of <code>const numbers = [1, 2, 3, 4];</code>.</li>\n<li>An <code>actual</code> of <code>const actual = numbers.flatMap(x =&gt; [x, x * 2]);</code>.</li>\n<li>An <code>expectation</code> of <code>expect(actual).toEqual([1, 2, 2, 4, 3, 6, 4, 8]);</code> where the expected result to check against is inline.</li>\n</ul>\n<h2>Test case 2</h2>\n<ol>\n<li>Test confirming that <code>flatMap</code> can take arrays of <strong>variable length</strong> strings and flat them out to a single array. In this case we have the <code>flatMap</code> callback <code>x =&gt; x.split(&quot; &quot;)</code> returning arrays of variable length from the input of <code>[&quot;it's Sunny in&quot;, &quot;&quot;, &quot;California&quot;]</code> we’ll get:\n<ul>\n<li><code>&quot;it's Sunny in&quot;</code> will yield <code>[&quot;it's&quot;, &quot;Sunny&quot;, &quot;in&quot;]</code> of length 3.</li>\n<li><code>&quot;&quot;</code> will yield <code>[&quot;&quot;]</code> of length 1.</li>\n<li><code>&quot;California always&quot;</code> will yield <code>[&quot;California&quot;, &quot;always&quot;]</code> of length 2.</li>\n<li>flattening those 3 arrays should yield one array of <code>[&quot;it's&quot;, &quot;Sunny&quot;, &quot;in&quot;, &quot;&quot;, &quot;California always&quot;]</code>.</li>\n</ul>\n</li>\n<li>The test has:</li>\n</ol>\n<ul>\n<li>An <code>input</code> of <code>const strings = [&quot;it's Sunny in&quot;, &quot;&quot;, &quot;California always&quot;];</code>.</li>\n<li>An <code>actual</code> of <code>const actual = strings.flatMap(x =&gt; x.split(&quot; &quot;));</code>.</li>\n<li>An <code>expectation</code> of <code>expect(actual).toEqual([&quot;it's&quot;, &quot;Sunny&quot;, &quot;in&quot;, &quot;&quot;, &quot;California always&quot;]);</code> where the expected result to check against is inline.</li>\n</ul>\n<h2>Test case 3</h2>\n<ol>\n<li>Test confirming that <code>flatMap</code> can take arrays of <strong>length 1</strong> and flat them out to a single array. In this case we have the <code>flatMap</code> callback <code>x =&gt; [x * 2]</code> returning arrays of length 1 from the input of <code>[1, 2, 3, 4]</code> we’ll get:\n<ul>\n<li><code>1</code> -&gt; <code>[2]</code>.</li>\n<li><code>2</code> -&gt; <code>[4]</code>.</li>\n<li><code>3</code> -&gt; <code>[6]</code>.</li>\n<li><code>4</code> -&gt; <code>[8]</code>.</li>\n<li>Flattening those 4 arrays should yield one of <code>[2, 4, 6, 8]</code>.</li>\n</ul>\n</li>\n<li>The test has:</li>\n</ol>\n<ul>\n<li>An <code>input</code> of <code>const numbers2 = [1, 2, 3, 4];</code>.</li>\n<li>An <code>actual</code> of <code>const actual = numbers2.flatMap(x =&gt; [x * 2]);</code>.</li>\n<li>An <code>expectation</code> of <code>expect(actual).toEqual([2, 4, 6, 8]);</code> where the expected result to check against is inline.</li>\n</ul>\n<h2>Test case 4</h2>\n<ol>\n<li>Test confirming that <code>flatMap</code> can take <strong>arrays of arrays</strong> and flat them <strong>one level</strong>. In this case we have the <code>flatMap</code> callback <code>x =&gt; [[x * 2]]</code> returning arrays of array from the input of <code>[1, 2, 3, 4]</code> we’ll get:\n<ul>\n<li><code>1</code> -&gt; <code>[[2]]</code>.</li>\n<li><code>2</code> -&gt; <code>[[4]]</code>.</li>\n<li><code>3</code> -&gt; <code>[[6]]</code>.</li>\n<li><code>4</code> -&gt; <code>[[8]]</code>.</li>\n<li>Flattening those 4 arrays should yield one of <code>[[2], [4], [6], [8]]</code>.</li>\n</ul>\n</li>\n<li>The test has:</li>\n</ol>\n<ul>\n<li>An <code>input</code> and an <code>actual</code> of <code>const actual = [1, 2, 3, 4].flatMap(x =&gt; [[x * 2]]);</code>.</li>\n<li>An <code>expectation</code> of <code>expect(actual).toEqual([[2], [4], [6], [8]]);</code> where the expected result to check against is inline,</li>\n</ul>\n<h2>Experiment</h2>\n<ul>\n<li>Change the input and see how tests change.\n<ul>\n<li>For example - in the test case 2, replace <code>const strings = [&quot;it's Sunny in&quot;, &quot;&quot;, &quot;California always&quot;];</code> with <code>const strings = [&quot;it's Sunny in&quot;, &quot;&quot;, &quot;California&quot;];</code>.</li>\n</ul>\n</li>\n<li>Change implementation and see how tests fail: Replace <code>return this.map(cb).reduce((acc, n) =&gt; acc.concat(n), []);</code>with <code>return this.map(cb).reduce((acc, n) =&gt; acc.concat(n), [1]);</code> adding the <code>1</code> in the array in <code>reduce</code>.</li>\n</ul>\n<h2>Naming the tests</h2>\n<p>The tests are presently named <code>test case 1</code> <code>test case 2</code>… That will be a problem for a reader of the tests. They lack the mental model of the issue at hand that the author does. That is if I read these test cases and don’t already know what the function does and why I will have a hard time understanding why the tests verify what they do.</p>\n<p>In other words, picking a <strong>descriptive</strong> name for each test case would benefit greatly the understanding of future <strong>readers</strong> <em>(in time that group will probably include the author)</em>.</p>\n<p>The renamed tests:</p>\n<ul>\n<li>The “test case 1” becomes “should flat arrays of length 2”.</li>\n<li>The “test case 2” becomes “should flat arrays of variable length”.</li>\n<li>The “test case 3” becomes “should flat arrays of length 1”.</li>\n<li>The “test case 4” becomes “should only flat one-level-deep nested arrays of arrays”.</li>\n</ul>\n","cursorPosition":{"line":0,"ch":0},"comp_id":"dDUrjgyjbEjOjgi9Oq01u"},"iteration":2,"hash":3,"saveVersion":9}],"summary":{"description":"In this lesson, we'll show that to test a function we use different inputs and outputs. We'll also look into naming the tests.\n","tags":["JavaScript","Function","Unit Test"],"titleUpdated":true}}