{"components":[{"type":"MarkdownEditor","content":{"version":"2.0","text":"One way of handling the API calls to the backend is in a class dedicated to a resource. In today's lesson we'll look at one such case. The `ArticleApiController` will implement a `get` method that provided an id returns the corresponding article. And a `delete` method that provided an `id` and an `etag` deletes the corresponding article.\n\nExplore the code in the next code playground and let's break it down after.","mdHtml":"<p>One way of handling the API calls to the backend is in a class dedicated to a resource. In today’s lesson we’ll look at one such case. The <code>ArticleApiController</code> will implement a <code>get</code> method that provided an id returns the corresponding article. And a <code>delete</code> method that provided an <code>id</code> and an <code>etag</code> deletes the corresponding article.</p>\n<p>Explore the code in the next code playground and let’s break it down after.</p>\n","cursorPosition":416,"comp_id":"VxNCAwvmaBg8p9nr5dccS"},"iteration":2,"hash":1,"saveVersion":2},{"type":"WebpackBin","mode":"edit","content":{"version":5,"theme":"default","showLineNumbers":true,"showConsole":false,"hideResultOutput":true,"hideOutputUrl":true,"hideCodeView":false,"loaders":{"babel":{"title":"React","config":{"es2015":true,"react":true},"enabled":true},"dart":{"title":"Dart","config":{"dart":true},"enabled":false},"ts-react":{"title":"Typescript React","config":{"ts-react":true},"enabled":false},"elm":{"title":"Elm","config":{"elm":true},"enabled":false},"vue":{"title":"Vue.js","config":{"vue":true},"enabled":false},"gojs-react":{"title":"GoJS React","config":{"gojs-react":true},"enabled":false}},"npmPackages":{"react":"15.6.1","react-dom":"15.6.1"},"outputHeight":300,"selectedApiKeys":{},"selectedEnvVars":{},"outputLayout":"desktop","codeContents":{"module":"/","id":0,"selectedId":null,"maxId":7479398031244,"children":[{"id":9590368138421,"module":"spec","leaf":false,"collapsed":true,"children":[{"id":6020278224184,"module":"support","leaf":false,"collapsed":true,"children":[{"id":4932491960168,"module":"jasmine.config.js","leaf":true,"data":{"content":"const SpecReporter = require('jasmine-spec-reporter').SpecReporter\r\n\r\njasmine.getEnv().clearReporters();\r\n\r\njasmine.getEnv().addReporter(\r\n  new SpecReporter({\r\n    // add jasmine-spec-reporter\r\n    spec: {\r\n      displayPending: true,\r\n    },\r\n  })\r\n)\r\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""}},{"id":5471704024585,"module":"jasmine.json","leaf":true,"data":{"content":"{\n  \"spec_dir\": \"src\",\n  \"spec_files\": [\n    \"**/*[sS]pec.js\"\n  ],\n  \"helpers\": [\n    \"../spec/support/jasmine.config.js\"\n  ],\n  \"stopSpecOnExpectationFailure\": false,\n  \"random\": false\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""}}]}]},{"id":7479398031244,"module":"src","leaf":false,"collapsed":true,"children":[{"id":6609498881984,"module":"article-controller.js","leaf":true,"data":{"content":"class ArticleController {\n  db;\n\n  constructor(db) {\n    this.db = db;\n  }\n\n  async get(id) {\n    try {\n      const a = await this.db.collection('Article').findOne({ id: id });\n      return a;\n    } catch (e) {\n      throw { status: 'not found', message: `Article with id \"${id}\" was not found.` };\n    }\n  }\n}\n\nexports.ArticleApiController = ArticleController;\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""}},{"id":9439156065109,"module":"article-controller.spec.js","leaf":true,"data":{"content":"const { ArticleApiController } = require('./article-controller.js');\n\ndescribe('ArticleApiController', () => {\n  let db;\n  let articleCollection;\n  let articleController;\n\n  beforeEach(() => {\n    articleCollection = jasmine.createSpyObj('collection', ['findOne', 'delete']);\n    db = jasmine.createSpyObj('db mock', {\n      collection: articleCollection,\n    });\n    articleController = new ArticleApiController(db);\n  });\n\n  describe('when get called', () => {\n    it('should search the article collection and resolve with the article when found', async () => {\n      // arrange\n      articleCollection.findOne.and.returnValue(Promise.resolve({ id: 1, title: 'Article', content: 'The lorem ipsum ...' }));\n      // act\n      const a = await articleController.get(1);\n      // assert\n      expect(articleCollection.findOne).toHaveBeenCalledOnceWith({ id: 1 });\n      expect(a).toEqual(jasmine.objectContaining({ id: 1 }));\n    });\n\n    it('should search the article collection and reject with an object with status and message', async () => {\n      // arrange\n      articleCollection.findOne.and.returnValue(Promise.reject({ error: 'eee' }));\n      // act\n      // assert\n      await expectAsync(articleController.get(1)).toBeRejectedWith({\n        status: 'not found',\n        message: 'Article with id \"1\" was not found.',\n      });\n    });\n  });\n});\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""}}]}],"importedGithubPath":"https://github.com/gparlakov/jasmine-educative/tree/main/3.4.server-endpoint","judge":{"judgeActive":false}},"dockerJob":{"key":"7IgoXRRQCavQ48Yy3YCL0","name":"live Jasmine","inputFileName":"src/main.ts","runScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec && cp -r /usercode/** .","ports":"9876","startScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec &&  cp -r /usercode/** . && node_modules/.bin/nodemon -w ../unit-testing-course/ ./node_modules/.bin/jasmine","jobType":"Live","forceRelaunchOnCompChange":true,"runInLiveContainer":true},"caption":"Example of testing async node.js API code","comp_id":"CL4ypXZSsDCGO7S_lcrxz"},"iteration":0,"hash":2},{"type":"MarkdownEditor","mode":"edit","content":{"version":"2.0","text":"## The class breakdown - ArticleApiController\n\nIf we are using a web framework like [express.js](https://expressjs.com/) it handles a lot of the HTTP stuff for us. We are left with the need to implement our logic. The `ArticleApiController` is this logic. It exposes a method `get` that allows clients to request an article by providing an `id`. Looking at `src/article-controller.js` :\n\n- ```js\n  db;\n\n  constructor(db) {\n    this.db = db;\n  }\n  ```\n\n  The `ArticleApiController` expects to get a `db` which would allow connecting and manipulating a database of some sort. This is a dependency and we'll mock it for the test so we won't get into further details here. For the example, it's assumed to be a [mongodb connection](https://docs.mongodb.com/drivers/node/current/)\n\n- ```js\n  async get(id) {\n    try {\n      const a = await this.db.collection('Article').findOne({ id: id });\n      return a;\n    } catch (e) {\n      throw { status: 'not found', message: `Article with id \"${id}\" was not found.` };\n    }\n  }\n  ```\n\n  This `async`-chronous method will return the article if found and will throw an error otherwise. The `try catch` wraps the call to the database and makes sure that if the connection fails or the article is not found or any other error occurs it is caught and an error with status and a message is thrown up. That error will presumably cause a `4xx` status response to be returned to the client over HTTP.\n\n  That logic will allow us to showcase `expectAsync`.\n\n- ```js\n  this.db.collection('Article').findOne({ id: id });\n  ```\n\n  This is an example of using a [mongodb collection](https://mongodb.github.io/node-mongodb-native/4.1/classes/Collection.html) to fetch a single entity [article](https://mongodb.github.io/node-mongodb-native/4.1/classes/Collection.html#findOne)\n\n## Tests breakdown\n\nThere are two tests in this example plus a `beforeEach` that will set up each test.\n\n- ```js\n  let db;\n  let articleCollection;\n  let articleController;\n\n  beforeEach(() => {\n    articleCollection = jasmine.createSpyObj('collection', ['findOne', 'delete']);\n    db = jasmine.createSpyObj('db mock', {\n      collection: articleCollection,\n    });\n    articleController = new ArticleApiController(db);\n  });\n  ```\n\n  Before each test, the logic above will run and create an instance of `ArticleApiController`. That will require an instance of `db` - the database access abstraction mock. The `db` exposes a method `collection` so we create the spy object with a `collection` method mock which returns the `articleCollection` spy object. The `articleCollection` is a spy object with spies on two methods - `findOne` and `delete`.\n\n- ```js\n  describe('when get called', () => {\n  ```\n\n  Notice we create a sub-suite `when get called` which will complement the `ArticleApiController` main suite. Each test from the sub-suite will get reported under the sub-suite which is reported under the main suite. That will come in handy later when we add tests for `delete` method (which is not included in this example for simplicity).\n\n- ```js\n  it('should search the article collection and resolve with the article when found', async () => {\n    // arrange\n    articleCollection.findOne.and.returnValue(\n      Promise.resolve({ id: 1, title: 'Article', content: 'The lorem ipsum ...' })\n    );\n    // act\n    const a = await articleController.get(1);\n    // assert\n    expect(articleCollection.findOne).toHaveBeenCalledOnceWith({ id: 1 });\n    expect(a).toEqual(jasmine.objectContaining({ id: 1 }));\n  });\n  ```\n\n  The above is an `async`-hronous test case that verifies the expected method `findOne` has been called and the final response returned is as expected:\n\n  - It provides a response for the `findOne` method - a `Promise` immediately resolving to an object with an `id`.\n  - It calls the `get` method giving a `1` for the `id` parameter.\n  - It asserts that the `db` method `findOne` has been called with the expected filter `{ id: 1}`.\n  - It asserts that the response is an object that contains a property of `id` that equals `1`.\n\n  This is the \"green\" path - the input is as expected and the output is the article.\n\n- ```js\n  it('should search the article collection and reject with an object with status and message', async () => {\n    // arrange\n    articleCollection.findOne.and.returnValue(Promise.reject({ error: 'eee' }));\n    // act\n    // assert\n    await expectAsync(articleController.get(1)).toBeRejectedWith({\n      status: 'not found',\n      message: 'Article with id \"1\" was not found.',\n    });\n  });\n  ```\n\n  The above is an `async`-hronous test case that verifies the `Promise` returned from the `get` method is rejected with the expected error status object:\n\n  - It provides a response to the `findOne` method - a `Promise` immediately rejecting with an error. Since there is no logic discerning different kinds of errors it doesn't matter what the error is.\n  - It uses and `await`-s the `expectAsync` function from [Jasmine](https://jasmine.github.io/api/3.9/global.html#expectAsync). It allows us to verify that a `Promise` is resolved or rejected with a specific value. In this case, we use the `toBeRejectedWith` to ensure that indeed the `articleController.get`'s response `Promise` rejects with the status and message as expected.\n\n  This is the expected failing case.\n\n  Notice that `// act` and `// assert` are next to one another. That's to denote that on the next line we act but also assert. The same logic could also separate the act from assert like this:\n\n  ```js\n  // act\n  const a = articleController.get(1);\n  // assert\n  await expectAsync(a).toBeRejectedWith({\n    status: 'not found',\n    message: 'Article with id \"1\" was not found.',\n  });\n  ```\n\n## Exercise\n\nFor the exercise let's try and test a `delete` method that is part of the `src/article-controller.js` file in the code playground below. The method accepts an `id` and an `etag` and checks if the [etag](https://en.wikipedia.org/wiki/HTTP_ETag) matches with the article found in the database:\n\n- If it matches - delete is a go and proceeds.\n- If it does not match the method throw a status object.\n- If the article is not found in the database the error caught is re-thrown. That's the error from the `get` method.\n- If the article delete fails a `delete failed` status object is thrown.\n\nUse the playground below to write a test case for each of the cases enumerated above. Replace the lines `pending(...)` with your code.\n","mdHtml":"<h2>The class breakdown - ArticleApiController</h2>\n<p>If we are using a web framework like <a href=\"https://expressjs.com/\">express.js</a> it handles a lot of the HTTP stuff for us. We are left with the need to implement our logic. The <code>ArticleApiController</code> is this logic. It exposes a method <code>get</code> that allows clients to request an article by providing an <code>id</code>. Looking at <code>src/article-controller.js</code> :</p>\n<ul>\n<li>\n<pre><code class=\"language-js\">db;\n\nconstructor(db) {\n  this.db = db;\n}\n</code></pre>\n<p>The <code>ArticleApiController</code> expects to get a <code>db</code> which would allow connecting and manipulating a database of some sort. This is a dependency and we’ll mock it for the test so we won’t get into further details here. For the example, it’s assumed to be a <a href=\"https://docs.mongodb.com/drivers/node/current/\">mongodb connection</a></p>\n</li>\n<li>\n<pre><code class=\"language-js\">async get(id) {\n  try {\n    const a = await this.db.collection('Article').findOne({ id: id });\n    return a;\n  } catch (e) {\n    throw { status: 'not found', message: `Article with id &quot;${id}&quot; was not found.` };\n  }\n}\n</code></pre>\n<p>This <code>async</code>-chronous method will return the article if found and will throw an error otherwise. The <code>try catch</code> wraps the call to the database and makes sure that if the connection fails or the article is not found or any other error occurs it is caught and an error with status and a message is thrown up. That error will presumably cause a <code>4xx</code> status response to be returned to the client over HTTP.</p>\n<p>That logic will allow us to showcase <code>expectAsync</code>.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">this.db.collection('Article').findOne({ id: id });\n</code></pre>\n<p>This is an example of using a <a href=\"https://mongodb.github.io/node-mongodb-native/4.1/classes/Collection.html\">mongodb collection</a> to fetch a single entity <a href=\"https://mongodb.github.io/node-mongodb-native/4.1/classes/Collection.html#findOne\">article</a></p>\n</li>\n</ul>\n<h2>Tests breakdown</h2>\n<p>There are two tests in this example plus a <code>beforeEach</code> that will set up each test.</p>\n<ul>\n<li>\n<pre><code class=\"language-js\">let db;\nlet articleCollection;\nlet articleController;\n\nbeforeEach(() =&gt; {\n  articleCollection = jasmine.createSpyObj('collection', ['findOne', 'delete']);\n  db = jasmine.createSpyObj('db mock', {\n    collection: articleCollection,\n  });\n  articleController = new ArticleApiController(db);\n});\n</code></pre>\n<p>Before each test, the logic above will run and create an instance of <code>ArticleApiController</code>. That will require an instance of <code>db</code> - the database access abstraction mock. The <code>db</code> exposes a method <code>collection</code> so we create the spy object with a <code>collection</code> method mock which returns the <code>articleCollection</code> spy object. The <code>articleCollection</code> is a spy object with spies on two methods - <code>findOne</code> and <code>delete</code>.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">describe('when get called', () =&gt; {\n</code></pre>\n<p>Notice we create a sub-suite <code>when get called</code> which will complement the <code>ArticleApiController</code> main suite. Each test from the sub-suite will get reported under the sub-suite which is reported under the main suite. That will come in handy later when we add tests for <code>delete</code> method (which is not included in this example for simplicity).</p>\n</li>\n<li>\n<pre><code class=\"language-js\">it('should search the article collection and resolve with the article when found', async () =&gt; {\n  // arrange\n  articleCollection.findOne.and.returnValue(\n    Promise.resolve({ id: 1, title: 'Article', content: 'The lorem ipsum ...' })\n  );\n  // act\n  const a = await articleController.get(1);\n  // assert\n  expect(articleCollection.findOne).toHaveBeenCalledOnceWith({ id: 1 });\n  expect(a).toEqual(jasmine.objectContaining({ id: 1 }));\n});\n</code></pre>\n<p>The above is an <code>async</code>-hronous test case that verifies the expected method <code>findOne</code> has been called and the final response returned is as expected:</p>\n<ul>\n<li>It provides a response for the <code>findOne</code> method - a <code>Promise</code> immediately resolving to an object with an <code>id</code>.</li>\n<li>It calls the <code>get</code> method giving a <code>1</code> for the <code>id</code> parameter.</li>\n<li>It asserts that the <code>db</code> method <code>findOne</code> has been called with the expected filter <code>{ id: 1}</code>.</li>\n<li>It asserts that the response is an object that contains a property of <code>id</code> that equals <code>1</code>.</li>\n</ul>\n<p>This is the “green” path - the input is as expected and the output is the article.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">it('should search the article collection and reject with an object with status and message', async () =&gt; {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.reject({ error: 'eee' }));\n  // act\n  // assert\n  await expectAsync(articleController.get(1)).toBeRejectedWith({\n    status: 'not found',\n    message: 'Article with id &quot;1&quot; was not found.',\n  });\n});\n</code></pre>\n<p>The above is an <code>async</code>-hronous test case that verifies the <code>Promise</code> returned from the <code>get</code> method is rejected with the expected error status object:</p>\n<ul>\n<li>It provides a response to the <code>findOne</code> method - a <code>Promise</code> immediately rejecting with an error. Since there is no logic discerning different kinds of errors it doesn’t matter what the error is.</li>\n<li>It uses and <code>await</code>-s the <code>expectAsync</code> function from <a href=\"https://jasmine.github.io/api/3.9/global.html#expectAsync\">Jasmine</a>. It allows us to verify that a <code>Promise</code> is resolved or rejected with a specific value. In this case, we use the <code>toBeRejectedWith</code> to ensure that indeed the <code>articleController.get</code>'s response <code>Promise</code> rejects with the status and message as expected.</li>\n</ul>\n<p>This is the expected failing case.</p>\n<p>Notice that <code>// act</code> and <code>// assert</code> are next to one another. That’s to denote that on the next line we act but also assert. The same logic could also separate the act from assert like this:</p>\n<pre><code class=\"language-js\">// act\nconst a = articleController.get(1);\n// assert\nawait expectAsync(a).toBeRejectedWith({\n  status: 'not found',\n  message: 'Article with id &quot;1&quot; was not found.',\n});\n</code></pre>\n</li>\n</ul>\n<h2>Exercise</h2>\n<p>For the exercise let’s try and test a <code>delete</code> method that is part of the <code>src/article-controller.js</code> file in the code playground below. The method accepts an <code>id</code> and an <code>etag</code> and checks if the <a href=\"https://en.wikipedia.org/wiki/HTTP_ETag\">etag</a> matches with the article found in the database:</p>\n<ul>\n<li>If it matches - delete is a go and proceeds.</li>\n<li>If it does not match the method throw a status object.</li>\n<li>If the article is not found in the database the error caught is re-thrown. That’s the error from the <code>get</code> method.</li>\n<li>If the article delete fails a <code>delete failed</code> status object is thrown.</li>\n</ul>\n<p>Use the playground below to write a test case for each of the cases enumerated above. Replace the lines <code>pending(...)</code> with your code.</p>\n","cursorPosition":5895,"comp_id":"80Y59LbAjYDw7CZ1YYUM_"},"iteration":1,"hash":3,"saveVersion":2},{"type":"WebpackBin","mode":"edit","content":{"version":5,"theme":"default","showLineNumbers":true,"showConsole":false,"hideResultOutput":true,"hideOutputUrl":true,"hideCodeView":false,"loaders":{"babel":{"title":"React","config":{"es2015":true,"react":true},"enabled":true},"dart":{"title":"Dart","config":{"dart":true},"enabled":false},"ts-react":{"title":"Typescript React","config":{"ts-react":true},"enabled":false},"elm":{"title":"Elm","config":{"elm":true},"enabled":false},"vue":{"title":"Vue.js","config":{"vue":true},"enabled":false},"gojs-react":{"title":"GoJS React","config":{"gojs-react":true},"enabled":false}},"npmPackages":{"react":"15.6.1","react-dom":"15.6.1"},"outputHeight":300,"selectedApiKeys":{},"selectedEnvVars":{},"outputLayout":"desktop","codeContents":{"module":"/","id":0,"selectedId":5597382324585,"maxId":3500562242627,"children":[{"id":6549418544271,"module":"spec","leaf":false,"collapsed":true,"children":[{"id":2507719418192,"module":"support","leaf":false,"collapsed":true,"children":[{"id":4720315554353,"module":"jasmine.config.js","leaf":true,"data":{"content":"const SpecReporter = require('jasmine-spec-reporter').SpecReporter\r\n\r\njasmine.getEnv().clearReporters();\r\n\r\njasmine.getEnv().addReporter(\r\n  new SpecReporter({\r\n    // add jasmine-spec-reporter\r\n    spec: {\r\n      displayPending: true,\r\n    },\r\n  })\r\n)\r\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""}},{"id":7364952972668,"module":"jasmine.json","leaf":true,"data":{"content":"{\n  \"spec_dir\": \"src\",\n  \"spec_files\": [\n    \"**/*[sS]pec.js\"\n  ],\n  \"helpers\": [\n    \"../spec/support/jasmine.config.js\"\n  ],\n  \"stopSpecOnExpectationFailure\": false,\n  \"random\": false\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""}}]}]},{"id":3500562242627,"module":"src","leaf":false,"collapsed":true,"children":[{"id":3208764412501,"module":"article-controller.js","leaf":true,"data":{"content":"class ArticleController {\n  db;\n\n  constructor(db) {\n    this.db = db;\n  }\n\n  async get(id) {\n    try {\n      const a = await this.db.collection('Article').findOne({ id: id });\n      return a;\n    } catch (e) {\n      throw { status: 'not found', message: `Article with id \"${id}\" was not found.` };\n    }\n  }\n\n  async delete(id, etag) {\n    try {\n      const article = await this.get(id);\n      if (article.version === etag) {\n        await this.db.collection('Article').delete({ id: id });\n      } else {\n        throw { status: 'version mismatch', message: `Article with id \"${id}\" seems to have been updated and client and server versions do not match.`}\n      }\n    } catch (e) {\n      if (e && typeof e.status === 'string') {\n        throw e;\n      }\n\n      throw { status: 'delete failed', message: `Article with id \"${id}\" could not be deleted.` };\n    }\n  }\n}\n\nexports.ArticleApiController = ArticleController;\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""}},{"id":5597382324585,"module":"article-controller.spec.js","leaf":true,"data":{"content":"const { ArticleApiController } = require('./article-controller.js');\n\ndescribe('ArticleApiController', () => {\n  let db;\n  let articleCollection;\n  let articleController;\n\n  beforeEach(() => {\n    articleCollection = jasmine.createSpyObj('collection', ['findOne', 'delete']);\n    db = jasmine.createSpyObj('db mock', {\n      collection: articleCollection,\n    });\n    articleController = new ArticleApiController(db);\n  });\n\n  describe('when get called', () => {\n    it('should search the article collection and resolve with the article when found', async () => {\n      // arrange\n      articleCollection.findOne.and.returnValue(Promise.resolve({ id: 1 }));\n      // act\n      const a = await articleController.get(1);\n      // assert\n      expect(articleCollection.findOne).toHaveBeenCalledOnceWith({ id: 1 });\n      expect(a).toEqual(jasmine.objectContaining({ id: 1 }));\n    });\n\n    it('should search the article collection and reject with an object with status and message', async () => {\n      // arrange\n      articleCollection.findOne.and.returnValue(Promise.reject({ error: 'eee' }));\n      // act\n      const a = await expectAsync(articleController.get(1)).toBeRejectedWith({\n        status: 'not found',\n        message: 'Article with id \"1\" was not found.',\n      });\n      // assert\n      expect(articleCollection.findOne).toHaveBeenCalledOnceWith({ id: 1 });\n    });\n  });\n\n  describe('when delete called', () => {\n    it('with an id and matching etag to version should delete the article', async () => {\n      // arrange\n      pending('add test logic here - hint - use `await expectAsync` ')\n      // act\n      // assert\n    });\n\n    it('with an id and mismatching etag to version should not delete the article and reject with a status object', async () => {\n      // arrange\n      pending('add test logic here - hint - use `await expectAsync` ')\n      // act\n      // assert\n    });\n\n    it('and get article fails it should reject with the same error', async () => {\n      // arrange\n      pending('add test logic here');\n      // act\n      // assert\n    });\n\n    it('and delete article in the DB fails it should reject with status object error', async () => {\n      // arrange\n      pending('add test logic here - hint - use `await expectAsync`');\n      // act\n      // assert\n    });\n  });\n});\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""}}]}],"importedGithubPath":"https://github.com/gparlakov/jasmine-educative/tree/main/3.4.server-endpoint-exercise"},"dockerJob":{"key":"7IgoXRRQCavQ48Yy3YCL0","name":"live Jasmine","inputFileName":"src/main.ts","runScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec && cp -r /usercode/** .","ports":"9876","startScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec &&  cp -r /usercode/** . && node_modules/.bin/nodemon -w ../unit-testing-course/ ./node_modules/.bin/jasmine","jobType":"Live","forceRelaunchOnCompChange":true,"runInLiveContainer":true},"caption":"Exercise: 4 test cases ","comp_id":"SSmdkxsqPqb_OluiXHnO_"},"iteration":15,"hash":4},{"type":"SpoilerEditor","mode":"edit","content":{"version":"3.0","text":"```js\nit('with an id and matching etag to version should delete the article', async () => {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.resolve({ id: 1, version: '2' }));\n  articleCollection.delete.and.returnValue(Promise.resolve({ id: 1, version: '2' }));\n  // act\n  const a = await articleController.delete(1, '2');\n  // assert\n  expect(articleCollection.delete).toHaveBeenCalledOnceWith({ id: 1 });\n});\n````","mdHtml":"<pre><code class=\"language-js\">it('with an id and matching etag to version should delete the article', async () =&gt; {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.resolve({ id: 1, version: '2' }));\n  articleCollection.delete.and.returnValue(Promise.resolve({ id: 1, version: '2' }));\n  // act\n  const a = await articleController.delete(1, '2');\n  // assert\n  expect(articleCollection.delete).toHaveBeenCalledOnceWith({ id: 1 });\n});\n</code></pre>\n","showHintText":"Show Hint for 'with an id and matching etag to version should delete the article'","hideHintText":"Hide Hint","showIcon":true,"comp_id":"UfDnUBMk_aERSedmAxndH"},"iteration":6,"hash":5,"saveVersion":1},{"type":"SpoilerEditor","mode":"view","content":{"version":"3.0","text":"```js\nit('with an id and mismatching etag to version should not delete the article and reject with a status object', async () => {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.resolve({ id: 1, version: '3' }));\n  articleCollection.delete.and.returnValue(Promise.resolve({ id: 1, version: '2' }));\n  // act\n  const deletePromise = articleController.delete(1, '2');\n  // assert\n  await expectAsync(deletePromise).toBeRejectedWith({\n    status: 'version mismatch',\n    message: 'Article with id \"1\" seems to have been updated and client and server versions do not match.',\n  });\n  expect(articleCollection.delete).not.toHaveBeenCalled();\n});\n```","mdHtml":"<pre><code class=\"language-js\">it('with an id and mismatching etag to version should not delete the article and reject with a status object', async () =&gt; {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.resolve({ id: 1, version: '3' }));\n  articleCollection.delete.and.returnValue(Promise.resolve({ id: 1, version: '2' }));\n  // act\n  const deletePromise = articleController.delete(1, '2');\n  // assert\n  await expectAsync(deletePromise).toBeRejectedWith({\n    status: 'version mismatch',\n    message: 'Article with id &quot;1&quot; seems to have been updated and client and server versions do not match.',\n  });\n  expect(articleCollection.delete).not.toHaveBeenCalled();\n});\n</code></pre>\n","showHintText":"Show Hint for 'with an id and mismatching etag to version should not delete the article and reject with a status object'","hideHintText":"Hide Hint","showIcon":true,"comp_id":"0YNcS3iFuDUXPu62wUFnO","isCopied":true},"iteration":6,"hash":6,"saveVersion":1},{"type":"SpoilerEditor","mode":"view","content":{"version":"3.0","text":"```js\nit('and get article fails it should reject with the same error', async () => {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.reject({ status: 'not found' }));\n  // act\n  // assert\n  await expectAsync(articleController.delete(1, '2')).toBeRejectedWith({\n    status: 'not found',\n    message: 'Article with id \"1\" was not found.'\n  });\n  expect(articleCollection.delete).not.toHaveBeenCalled();\n})\n```","mdHtml":"<pre><code class=\"language-js\">it('and get article fails it should reject with the same error', async () =&gt; {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.reject({ status: 'not found' }));\n  // act\n  // assert\n  await expectAsync(articleController.delete(1, '2')).toBeRejectedWith({\n    status: 'not found',\n    message: 'Article with id &quot;1&quot; was not found.'\n  });\n  expect(articleCollection.delete).not.toHaveBeenCalled();\n})\n</code></pre>\n","showHintText":"Show Hint for 'and get article fails it should reject with the same error'","hideHintText":"Hide Hint","showIcon":true,"comp_id":"JkgepIWY6onwxvJ-4GHeG","isCopied":true},"iteration":6,"hash":7,"saveVersion":1},{"type":"SpoilerEditor","mode":"view","content":{"version":"3.0","text":"```js\nit('and delete article in the DB fails it should reject with status object error', async () => {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.resolve({ id: 1, version: '3' }));\n  articleCollection.delete.and.returnValue(Promise.reject({}));\n  // act\n  // assert\n  await expectAsync(articleController.delete(1, '3')).toBeRejectedWith({\n    status: 'delete failed',\n    message: `Article with id \"1\" could not be deleted.`,\n  });\n});\n```","mdHtml":"<pre><code class=\"language-js\">it('and delete article in the DB fails it should reject with status object error', async () =&gt; {\n  // arrange\n  articleCollection.findOne.and.returnValue(Promise.resolve({ id: 1, version: '3' }));\n  articleCollection.delete.and.returnValue(Promise.reject({}));\n  // act\n  // assert\n  await expectAsync(articleController.delete(1, '3')).toBeRejectedWith({\n    status: 'delete failed',\n    message: `Article with id &quot;1&quot; could not be deleted.`,\n  });\n});\n</code></pre>\n","showHintText":"Show Hint for 'and delete article in the DB fails it should reject with status object error'","hideHintText":"Hide Hint","showIcon":true,"comp_id":"RXPkVQB8pae9WxRL-KTWo","isCopied":true},"iteration":7,"hash":8,"saveVersion":2}],"summary":{"title":"How to Test SPA Components","description":"We'll take a look at the back-end side and how to test an implementation of a `ArticleApiController` with asynchronous `get` and `delete` endpoints.\n","tags":["expectAsync","Nodejs","API"],"titleUpdated":true}}