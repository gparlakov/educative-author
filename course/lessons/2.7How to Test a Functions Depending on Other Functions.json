{"components":[{"type":"MarkdownEditor","content":{"version":"2.0","text":"## The function\n\nThe function `maybeString` takes a parameter and a callback and calls the callback only if the parameter is a string. The callback is the function that `maybeString` depends on for its logic.\n\n```js\nfunction maybeString(str, callback) {\n  if (typeof str === 'string' && typeof callback === 'function') {\n    return callback(str);\n  }\n}\n```\n\nThe expression `typeof str === 'string' && typeof callback === 'function'` will be `true` only if:\n\n- the `str` parameter is actually a string and not `null` or `object` or `number`, etc.\n- the `callback` parameter is actually a `function` and not `null` or `object`, etc.\n\nIf the above holds true then the function will return the result of calling `callback` and passing `str`.\n\n_Incidentally if the above does not hold true our function will return `undefined` as Javascript considers any function completing without hitting a `return` statement to have a `return undefined;` or `return;` [MDN Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#description)._\n\n## Mocking and spying\n\nTo be able to test `maybeString` we need to provide the `callback` function. Instead of providing just any function, we'll use a construct called `spy` which is a function that monitors its calls and can provide a specified response. A mock function. Such a function will take the place of `callback` and we can:\n\n- tell it what to return\n- tell it to throw an error\n- ask it how many times it was called and what parameters it was called with\n\n## Example\n\nRun the code playground below for an example of testing a function using mocks.\n","mdHtml":"<h2>The function</h2>\n<p>The function <code>maybeString</code> takes a parameter and a callback and calls the callback only if the parameter is a string. The callback is the function that <code>maybeString</code> depends on for its logic.</p>\n<pre><code class=\"language-js\">function maybeString(str, callback) {\n  if (typeof str === 'string' &amp;&amp; typeof callback === 'function') {\n    return callback(str);\n  }\n}\n</code></pre>\n<p>The expression <code>typeof str === 'string' &amp;&amp; typeof callback === 'function'</code> will be <code>true</code> only if:</p>\n<ul>\n<li>the <code>str</code> parameter is actually a string and not <code>null</code> or <code>object</code> or <code>number</code>, etc.</li>\n<li>the <code>callback</code> parameter is actually a <code>function</code> and not <code>null</code> or <code>object</code>, etc.</li>\n</ul>\n<p>If the above holds true then the function will return the result of calling <code>callback</code> and passing <code>str</code>.</p>\n<p><em>Incidentally if the above does not hold true our function will return <code>undefined</code> as Javascript considers any function completing without hitting a <code>return</code> statement to have a <code>return undefined;</code> or <code>return;</code> <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions#description\">MDN Function</a>.</em></p>\n<h2>Mocking and spying</h2>\n<p>To be able to test <code>maybeString</code> we need to provide the <code>callback</code> function. Instead of providing just any function, we’ll use a construct called <code>spy</code> which is a function that monitors its calls and can provide a specified response. A mock function. Such a function will take the place of <code>callback</code> and we can:</p>\n<ul>\n<li>tell it what to return</li>\n<li>tell it to throw an error</li>\n<li>ask it how many times it was called and what parameters it was called with</li>\n</ul>\n<h2>Example</h2>\n<p>Run the code playground below for an example of testing a function using mocks.</p>\n","cursorPosition":0,"comp_id":"ZOouQk33Jphg8aSmlrgDw"},"iteration":4,"hash":1,"saveVersion":18},{"type":"WebpackBin","mode":"edit","content":{"version":5,"theme":"default","showLineNumbers":true,"showConsole":true,"hideResultOutput":true,"hideOutputUrl":true,"hideCodeView":false,"loaders":{"babel":{"title":"React","config":{"es2015":true,"react":true},"enabled":true},"dart":{"title":"Dart","config":{"dart":true},"enabled":false},"ts-react":{"title":"Typescript React","config":{"ts-react":true},"enabled":false},"elm":{"title":"Elm","config":{"elm":true},"enabled":false},"vue":{"title":"Vue.js","config":{"vue":true},"enabled":false},"gojs-react":{"title":"GoJS React","config":{"gojs-react":true},"enabled":false}},"npmPackages":{"react":"15.6.1","react-dom":"15.6.1"},"outputHeight":"400","selectedApiKeys":{},"selectedEnvVars":{},"outputLayout":"desktop","codeContents":{"module":"/","id":0,"selectedId":9816789464598,"maxId":7652667676418,"children":[{"id":8338860626924,"module":"spec","leaf":false,"collapsed":true,"children":[{"id":9451977459909,"module":"support","leaf":false,"collapsed":true,"children":[{"id":3738175938462,"module":"jasmine.config.js","leaf":true,"data":{"content":"const SpecReporter = require('jasmine-spec-reporter').SpecReporter\r\n\r\njasmine.getEnv().clearReporters();\r\n\r\njasmine.getEnv().addReporter(\r\n  new SpecReporter({\r\n    // add jasmine-spec-reporter\r\n    spec: {\r\n      displayPending: true,\r\n    },\r\n  })\r\n)\r\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":9451977459909},{"id":5022575660385,"module":"jasmine.json","leaf":true,"data":{"content":"{\n  \"spec_dir\": \"src\",\n  \"spec_files\": [\n    \"**/*[sS]pec.js\"\n  ],\n  \"helpers\": [\n    \"../spec/support/jasmine.config.js\"\n  ],\n  \"stopSpecOnExpectationFailure\": false,\n  \"random\": false\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":9451977459909}],"parentId":8338860626924}],"parentId":0},{"id":7652667676418,"module":"src","leaf":false,"collapsed":true,"children":[{"id":3978844480866,"module":"maybe-string.js","leaf":true,"data":{"content":"/**\n * @param {string} str\n * @param {(s: string) => any} callback\n */\nexports.maybeString = function maybeString(str, callback) {\n  if(typeof str === 'string' && typeof callback === 'function') {\n    return callback(str);\n  }\n}\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":7652667676418},{"id":9816789464598,"module":"maybe-string.spec.js","leaf":true,"data":{"content":"const { maybeString } = require('./maybe-string');\n\ndescribe('maybe-string', () => {\n\n  it('should call the callback if string passed in', () => {\n    const spy = jasmine.createSpy('callback');\n    maybeString('s', spy);\n\n    expect(spy).toHaveBeenCalled();\n    expect(spy).toHaveBeenCalledTimes(1);\n    expect(spy).toHaveBeenCalledWith('s');\n  });\n\n  it('should not call the callback if no null, number or object passed in', () => {\n    const spy = jasmine.createSpy('callback');\n    maybeString(null, spy);\n    maybeString(undefined, spy);\n    maybeString(1, spy);\n    maybeString({}, spy);\n\n    expect(spy).not.toHaveBeenCalled();\n  });\n\n  it('should return undefined if no callback is passed in', () => {\n    const actual = maybeString('string', null);\n    expect(actual).toBeUndefined();\n  });\n\n  it('should return the result of callback when string', () => {\n    pending('excercise')\n    const actual = maybeString('my string', s => s.length);\n\n    // exercise: finish 👇 this \n    // expect(actual).to....;\n  });\n});\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":7652667676418}],"parentId":0}],"importedGithubPath":"https://github.com/gparlakov/using-jasmine-and-karma-to-unit-test-your-angular-app/tree/main/mocking-dependencies","judge":{"judgeActive":false}},"dockerJob":{"key":"7IgoXRRQCavQ48Yy3YCL0","name":"live Jasmine","inputFileName":"src/main.ts","runScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec && cp -r /usercode/** .","ports":"9876","startScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec &&  cp -r /usercode/** . && node_modules/.bin/nodemon -w ../unit-testing-course/ ./node_modules/.bin/jasmine","jobType":"Live","forceRelaunchOnCompChange":true,"runInLiveContainer":true},"comp_id":"hksXfmgXzE2vcQcRdpyzG","caption":"Example of spying function and mocking results"},"iteration":7,"hash":2,"saveVersion":23},{"type":"MarkdownEditor","mode":"edit","content":{"version":"2.0","text":"## Breakdown of `maybeString`\n\nThe file `src/maybe-string.spec.js` contains the test cases for the `maybeString` function. Since that function accepts a callback and has logic that decides when to call that, the tests need to make sure that the callback is called when it's supposed to and not otherwise.\n\n### The spy\n\nThe expression `const spy = jasmine.createSpy('callback');` defines a constant of `spy` and assigns the return from `jasmine.createSpy`.\n\nThe method call `jasmine.createSpy('callback')` will return a spy. That's a function with a few special capabilities - properties and methods. First and foremost, this is a function just like any other in JavaScript. It accepts any number of parameters ([arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments)). The spy capabilities include allowing expectations to be performed against the count and parameters of method calls:\n\n- The expectation `expect(spy).toHaveBeenCalled()` verifies that the `spy` function has been called.\n- The expectation `expect(spy).toHaveBeenCalledTimes(1)` verifies that the `spy` function has been called one time exactly _(could be used instead of the above in this case)_.\n- The expectation `expect(spy).toHaveBeenCalledWith('s')` verifies that the `spy` function has been called with a parameter of `'s'`.\n  > The expectation `expect(spy).toHaveBeenCalledWith('s', 1, 2)` - can be used with multiple parameters too.\n\n## The \"called\" case\n\nVerifies that `maybeString` actually calls the callback when it is supposed to e.g. there is a `string` parameter and a `function` parameter. The spec is `it('should call the callback if string passed in', () => {` and it utilizes the `toHaveBeenCalled..` expectations mentioned just above.\n\n## The \"not called\" case\n\nVerifies that `maybeString` does not call the callback when no `string` or `callback` is provided. It starts with creating a spy and calling the `maybeString` with non-string values as the first parameter. Then it uses the `.not` after the expectation negating the expectations after it. That is `expect(spy).not.toHaveBeenCalled();` will verify `spy` has not been called as a result of the `maybeString` calls with non-string values.\n\n## The other \"not called\" case\n\nThere is another case we should verify - when the first parameter is indeed a `string` but the second is not a `function`. For example `maybeString('string', null)`. For this case, we can not use a `spy` since the `null` value can not be spied upon. So to verify the expectation we can use the result of the function. Namely - expect that `undefined` is returned when no callback is passed in.\n\n## Exercise \"green path\"\n\nThe \"green\" path is left as an exercise. Verify that when both the `str` and `callback` parameters are passed in and meet expectations then the function returns the result of the `callback(str)` expression.\n\n## The config function\n\nSometimes a function receives an object as a parameter and uses a method from that object.\n\nFor example:\n\n```js\nfunction config(configObj) {\n  if (configObj && typeof configObj.configure === 'function') {\n    configObj = configObj.configure(configObj);\n  }\n\n  return configObj;\n}\n```\n\nA `config` function that receives an object `configObj` that may or may not have a `configure` an attached function (aka method). That function then returns the configured object for use. Such a pattern is used in JavaScript libraries and such.\n\nHow do we go about testing such a function?\n\n## SpyOn\n\n`spyOn` is a globally-available-Jasmine function that takes an object as a first parameter and then a method name for it to create and install spy for. The spy function replaces the original and serves as a proxy for it, allows configuring the return value, and keeps track of calls and parameters.\n\n```js\nconst object = {\n   myFunction: () => {....}\n}\n\nspyOn(object,  'myFunction')\n```\n\nNow the `object` can be passed as a parameter to the function under test and then used to ascertain that a call was made and made using a specific set of parameters.\n\nSee `src/config.spec.js` in the code playground below for a working example.\n","mdHtml":"<h2>Breakdown of <code>maybeString</code></h2>\n<p>The file <code>src/maybe-string.spec.js</code> contains the test cases for the <code>maybeString</code> function. Since that function accepts a callback and has logic that decides when to call that, the tests need to make sure that the callback is called when it’s supposed to and not otherwise.</p>\n<h3>The spy</h3>\n<p>The expression <code>const spy = jasmine.createSpy('callback');</code> defines a constant of <code>spy</code> and assigns the return from <code>jasmine.createSpy</code>.</p>\n<p>The method call <code>jasmine.createSpy('callback')</code> will return a spy. That’s a function with a few special capabilities - properties and methods. First and foremost, this is a function just like any other in JavaScript. It accepts any number of parameters (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments\">arguments</a>). The spy capabilities include allowing expectations to be performed against the count and parameters of method calls:</p>\n<ul>\n<li>The expectation <code>expect(spy).toHaveBeenCalled()</code> verifies that the <code>spy</code> function has been called.</li>\n<li>The expectation <code>expect(spy).toHaveBeenCalledTimes(1)</code> verifies that the <code>spy</code> function has been called one time exactly <em>(could be used instead of the above in this case)</em>.</li>\n<li>The expectation <code>expect(spy).toHaveBeenCalledWith('s')</code> verifies that the <code>spy</code> function has been called with a parameter of <code>'s'</code>.\n<blockquote>\n<p>The expectation <code>expect(spy).toHaveBeenCalledWith('s', 1, 2)</code> - can be used with multiple parameters too.</p>\n</blockquote>\n</li>\n</ul>\n<h2>The “called” case</h2>\n<p>Verifies that <code>maybeString</code> actually calls the callback when it is supposed to e.g. there is a <code>string</code> parameter and a <code>function</code> parameter. The spec is <code>it('should call the callback if string passed in', () =&gt; {</code> and it utilizes the <code>toHaveBeenCalled..</code> expectations mentioned just above.</p>\n<h2>The “not called” case</h2>\n<p>Verifies that <code>maybeString</code> does not call the callback when no <code>string</code> or <code>callback</code> is provided. It starts with creating a spy and calling the <code>maybeString</code> with non-string values as the first parameter. Then it uses the <code>.not</code> after the expectation negating the expectations after it. That is <code>expect(spy).not.toHaveBeenCalled();</code> will verify <code>spy</code> has not been called as a result of the <code>maybeString</code> calls with non-string values.</p>\n<h2>The other “not called” case</h2>\n<p>There is another case we should verify - when the first parameter is indeed a <code>string</code> but the second is not a <code>function</code>. For example <code>maybeString('string', null)</code>. For this case, we can not use a <code>spy</code> since the <code>null</code> value can not be spied upon. So to verify the expectation we can use the result of the function. Namely - expect that <code>undefined</code> is returned when no callback is passed in.</p>\n<h2>Exercise “green path”</h2>\n<p>The “green” path is left as an exercise. Verify that when both the <code>str</code> and <code>callback</code> parameters are passed in and meet expectations then the function returns the result of the <code>callback(str)</code> expression.</p>\n<h2>The config function</h2>\n<p>Sometimes a function receives an object as a parameter and uses a method from that object.</p>\n<p>For example:</p>\n<pre><code class=\"language-js\">function config(configObj) {\n  if (configObj &amp;&amp; typeof configObj.configure === 'function') {\n    configObj = configObj.configure(configObj);\n  }\n\n  return configObj;\n}\n</code></pre>\n<p>A <code>config</code> function that receives an object <code>configObj</code> that may or may not have a <code>configure</code> an attached function (aka method). That function then returns the configured object for use. Such a pattern is used in JavaScript libraries and such.</p>\n<p>How do we go about testing such a function?</p>\n<h2>SpyOn</h2>\n<p><code>spyOn</code> is a globally-available-Jasmine function that takes an object as a first parameter and then a method name for it to create and install spy for. The spy function replaces the original and serves as a proxy for it, allows configuring the return value, and keeps track of calls and parameters.</p>\n<pre><code class=\"language-js\">const object = {\n   myFunction: () =&gt; {....}\n}\n\nspyOn(object,  'myFunction')\n</code></pre>\n<p>Now the <code>object</code> can be passed as a parameter to the function under test and then used to ascertain that a call was made and made using a specific set of parameters.</p>\n<p>See <code>src/config.spec.js</code> in the code playground below for a working example.</p>\n","cursorPosition":{"line":0,"ch":0},"comp_id":"w7yuzvdC49twY17lF_-Bv"},"iteration":3,"hash":3,"saveVersion":12},{"type":"WebpackBin","mode":"view","content":{"version":5,"theme":"default","showLineNumbers":true,"showConsole":true,"hideResultOutput":true,"hideOutputUrl":true,"hideCodeView":false,"loaders":{"babel":{"title":"React","config":{"es2015":true,"react":true},"enabled":true},"dart":{"title":"Dart","config":{"dart":true},"enabled":false},"ts-react":{"title":"Typescript React","config":{"ts-react":true},"enabled":false},"elm":{"title":"Elm","config":{"elm":true},"enabled":false},"vue":{"title":"Vue.js","config":{"vue":true},"enabled":false},"gojs-react":{"title":"GoJS React","config":{"gojs-react":true},"enabled":false}},"npmPackages":{"react":"15.6.1","react-dom":"15.6.1"},"outputHeight":"300","selectedApiKeys":{},"selectedEnvVars":{},"outputLayout":"desktop","codeContents":{"module":"/","id":0,"selectedId":3891661522620,"maxId":1077522163044,"children":[{"id":2835616218409,"module":"spec","leaf":false,"collapsed":true,"children":[{"id":9911234796779,"module":"support","leaf":false,"collapsed":true,"children":[{"id":5565881069718,"module":"jasmine.config.js","leaf":true,"data":{"content":"const SpecReporter = require('jasmine-spec-reporter').SpecReporter\r\n\r\njasmine.getEnv().clearReporters();\r\n\r\njasmine.getEnv().addReporter(\r\n  new SpecReporter({\r\n    // add jasmine-spec-reporter\r\n    spec: {\r\n      displayPending: true,\r\n    },\r\n  })\r\n)\r\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":9911234796779},{"id":1641744020538,"module":"jasmine.json","leaf":true,"data":{"content":"{\n  \"spec_dir\": \"src\",\n  \"spec_files\": [\n    \"**/*[sS]pec.js\"\n  ],\n  \"helpers\": [\n    \"../spec/support/jasmine.config.js\"\n  ],\n  \"stopSpecOnExpectationFailure\": false,\n  \"random\": false\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":9911234796779}],"parentId":2835616218409}],"parentId":0},{"id":1077522163043,"module":"src","leaf":false,"collapsed":true,"children":[{"id":5759371234846,"module":"config.js","leaf":true,"data":{"content":"exports.config = function config(configObj) {\n    if(configObj && typeof configObj.configure === 'function') {\n        configObj = configObj.configure(configObj);\n    }\n\n    return configObj;\n}\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":1077522163043,"hideFile":false,"enableHiddenCode":false,"hiddenCodeContent":{"prependCode":"\n\n","appendCode":"\n\n","codeSelection":"prependCode"}},{"id":3891661522620,"module":"config.spec.js","leaf":true,"data":{"content":"const { config } = require('./config');\n\ndescribe('config', () => {\n  it('should call the configure callback if one passed', () => {\n    const c = {\n      myConfig: 1,\n      configure: () => {},\n    };\n    const configureSpy = spyOn(c, 'configure');\n    config(c);\n\n    expect(configureSpy).toHaveBeenCalled();\n    expect(configureSpy).toHaveBeenCalledTimes(1);\n    expect(configureSpy).toHaveBeenCalledWith(jasmine.objectContaining({ myConfig: 1 }));\n  });\n\n  it('should replace the configure callback', () => {\n    const c = {\n      myConfig: 1,\n      configure: () => ({}),\n    };\n    const configureSpy = spyOn(c, 'configure').and.returnValue({ myConfig: 100 });\n    const actual = config(c);\n\n    expect(actual).toEqual({ myConfig: 100 });\n\n    expect(configureSpy).toHaveBeenCalledTimes(1);\n  });\n\n  it('should call through to the the configure callback', () => {\n    const c = {\n      myConfig: 1,\n      configure: (o) => {\n        return { myConfig: o.myConfig * 5 };\n      },\n    };\n    const configureSpy = spyOn(c, 'configure').and.callThrough();\n    const actual = config(c);\n\n    expect(actual).toEqual({ myConfig: 5 });\n\n    expect(configureSpy).toHaveBeenCalledTimes(1);\n  });\n});\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":1077522163043}],"parentId":0}],"importedGithubPath":"https://github.com/gparlakov/using-jasmine-and-karma-to-unit-test-your-angular-app/tree/main/mocking-dependencies","judge":{"judgeActive":false}},"dockerJob":{"key":"7IgoXRRQCavQ48Yy3YCL0","name":"live Jasmine","inputFileName":"src/main.ts","runScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec && cp -r /usercode/** .","ports":"9876","startScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec &&  cp -r /usercode/** . && node_modules/.bin/nodemon -w ../unit-testing-course/ ./node_modules/.bin/jasmine","jobType":"Live","forceRelaunchOnCompChange":true,"runInLiveContainer":true},"comp_id":"H19G_C-9Ppnav3JshJwEe","isCopied":true,"caption":"Example of spying on object method"},"saveVersion":25,"iteration":4,"hash":4},{"type":"MarkdownEditor","mode":"edit","content":{"version":"2.0","text":"\n## Breakdown\n\n### spyOn\n\n`'should call the configure callback if one passed'`\nFocusing on the first test case (lines 4 through to 15)\n\n- ```js\n  const c = {\n    myConfig: 1,\n    configure: () => {},\n  };\n  ```\n\n  Creates an object as the input of the function-under-test (`config`).\n\n- ```js\n  const configureSpy = spyOn(c, 'configure');\n  ```\n\n  Applies `spyOn` on the `c` object and its `configure` method.\n\n  It says: \"Hey, Jasmine, go ahead and install a spy in the `c.configure` method and be ready to intercept any and all calls to it and replace the output!\".\n\n- ```js\n  config(c);\n  ```\n\n  Is the call to the function-under-test.\n\n- ```js\n  expect(configureSpy).toHaveBeenCalled();\n  ```\n\n  The expectations assert that there's been **at least one** call to the spied upon `c.configure` method.\n\n- ```js\n  expect(configureSpy).toHaveBeenCalledTimes(1);\n  ```\n\n  The expectations assert that there's been **one and only one** call to the spied upon `c.configure` method.\n\n- ```js\n  expect(configureSpy).toHaveBeenCalledWith(jasmine.objectContaining({ myConfig: 1 }));\n  ```\n\n  The expectation asserts that there's been at least one call to the spied upon `c.configure` method with an object that contains this property `myConfig` and value `1`.\n\n### Using `returnValue` method\n\nIn the 'should replace the configure callback' case there are 2 major differences:\n\n1. There's a `.and.returnValue` call after the `spyOn` which says:\n    - \"Hey, Jasmine, go ahead and return this value for any and all calls to the spied upon `c.configure` method!\".\n2. The `actual` result from the function is now used in an expectation that proves the returned value comes from the spy:\n\n   ```js\n   const configureSpy = spyOn(c, 'configure').and.returnValue({ myConfig: 100 }); // ^\n   const actual = config(c); // v\n   expect(actual).toEqual({ myConfig: 100 });\n   ```\n\n   (lines formatted to align horizontally)\n\n   _This test case proves little more than that the spyOn works as expected, and would be redundant in an actual application testing code._\n\n### The `callThrough` method\n\nLet's look at the 'should call through to the configure callback' case.\n\n_Another test that only proves Jasmine right and would be redundant in an actual application testing code._\n\n```js\nconst configureSpy = spyOn(c, 'configure').and.callThrough();\n```\n\n\"Hey, Jasmine, go ahead and let the calls to the spied `c.configure` method pass through you and return the actual result from the original method `configure`.\"\n\nThat's useful when we'd like to spy upon the calls but not interrupt them.\n\nThe expectation `expect(actual).toEqual({ myConfig: 5 });` asserts the call was indeed handled by the original method and `expect(configureSpy).toHaveBeenCalledTimes(1);` asserts that the spy has indeed collected the call information.\n\n### The `callFake` method\n\nThere's also a `callFake` method that replaces the called function and facilitates more complex logic.\n\nFor a somewhat contrived example:\n\n```js\nvar calls = 0;\nspyOn(c, 'configure').and.callFake(() => {\n  if (calls === 0) {\n    calls++;\n    return undefined;\n  } else {\n    return 1;\n  }\n});\n```\n\nThis replaced function will return `undefined` for the first call and 1 for each subsequent.\n\n## Exercise spying methods and mocking responses\n\nThere are two files in `src/exercise` folder:\n\n- The file `maybe-number.js` - calls a callback if a number was passed in. Test that using the `jasmine.createSpy` capability.\n- The file `config-retries.js` - configures the `retry` count of a configuration object. Test that, using the `spyOn` capability and the following test cases:\n      - Case when `.retries` is a function, and it is called once and only once and with the expected input (`defaultRetries`).\n      - Case when `.retries` is a number that number is the configured `retry`.\n      - Case when `.retries` is not a function or a number, and the `defaultRetries` is the configured `retry` count.\n\nUse the next playground:\n","mdHtml":"<h2>Breakdown</h2>\n<h3>spyOn</h3>\n<p><code>'should call the configure callback if one passed'</code>\nFocusing on the first test case (lines 4 through to 15)</p>\n<ul>\n<li>\n<pre><code class=\"language-js\">const c = {\n  myConfig: 1,\n  configure: () =&gt; {},\n};\n</code></pre>\n<p>Creates an object as the input of the function-under-test (<code>config</code>).</p>\n</li>\n<li>\n<pre><code class=\"language-js\">const configureSpy = spyOn(c, 'configure');\n</code></pre>\n<p>Applies <code>spyOn</code> on the <code>c</code> object and its <code>configure</code> method.</p>\n<p>It says: “Hey, Jasmine, go ahead and install a spy in the <code>c.configure</code> method and be ready to intercept any and all calls to it and replace the output!”.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">config(c);\n</code></pre>\n<p>Is the call to the function-under-test.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">expect(configureSpy).toHaveBeenCalled();\n</code></pre>\n<p>The expectations assert that there’s been <strong>at least one</strong> call to the spied upon <code>c.configure</code> method.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">expect(configureSpy).toHaveBeenCalledTimes(1);\n</code></pre>\n<p>The expectations assert that there’s been <strong>one and only one</strong> call to the spied upon <code>c.configure</code> method.</p>\n</li>\n<li>\n<pre><code class=\"language-js\">expect(configureSpy).toHaveBeenCalledWith(jasmine.objectContaining({ myConfig: 1 }));\n</code></pre>\n<p>The expectation asserts that there’s been at least one call to the spied upon <code>c.configure</code> method with an object that contains this property <code>myConfig</code> and value <code>1</code>.</p>\n</li>\n</ul>\n<h3>Using <code>returnValue</code> method</h3>\n<p>In the ‘should replace the configure callback’ case there are 2 major differences:</p>\n<ol>\n<li>\n<p>There’s a <code>.and.returnValue</code> call after the <code>spyOn</code> which says:</p>\n<ul>\n<li>“Hey, Jasmine, go ahead and return this value for any and all calls to the spied upon <code>c.configure</code> method!”.</li>\n</ul>\n</li>\n<li>\n<p>The <code>actual</code> result from the function is now used in an expectation that proves the returned value comes from the spy:</p>\n<pre><code class=\"language-js\">const configureSpy = spyOn(c, 'configure').and.returnValue({ myConfig: 100 }); // ^\nconst actual = config(c); // v\nexpect(actual).toEqual({ myConfig: 100 });\n</code></pre>\n<p>(lines formatted to align horizontally)</p>\n<p><em>This test case proves little more than that the spyOn works as expected, and would be redundant in an actual application testing code.</em></p>\n</li>\n</ol>\n<h3>The <code>callThrough</code> method</h3>\n<p>Let’s look at the ‘should call through to the configure callback’ case.</p>\n<p><em>Another test that only proves Jasmine right and would be redundant in an actual application testing code.</em></p>\n<pre><code class=\"language-js\">const configureSpy = spyOn(c, 'configure').and.callThrough();\n</code></pre>\n<p>“Hey, Jasmine, go ahead and let the calls to the spied <code>c.configure</code> method pass through you and return the actual result from the original method <code>configure</code>.”</p>\n<p>That’s useful when we’d like to spy upon the calls but not interrupt them.</p>\n<p>The expectation <code>expect(actual).toEqual({ myConfig: 5 });</code> asserts the call was indeed handled by the original method and <code>expect(configureSpy).toHaveBeenCalledTimes(1);</code> asserts that the spy has indeed collected the call information.</p>\n<h3>The <code>callFake</code> method</h3>\n<p>There’s also a <code>callFake</code> method that replaces the called function and facilitates more complex logic.</p>\n<p>For a somewhat contrived example:</p>\n<pre><code class=\"language-js\">var calls = 0;\nspyOn(c, 'configure').and.callFake(() =&gt; {\n  if (calls === 0) {\n    calls++;\n    return undefined;\n  } else {\n    return 1;\n  }\n});\n</code></pre>\n<p>This replaced function will return <code>undefined</code> for the first call and 1 for each subsequent.</p>\n<h2>Exercise spying methods and mocking responses</h2>\n<p>There are two files in <code>src/exercise</code> folder:</p>\n<ul>\n<li>The file <code>maybe-number.js</code> - calls a callback if a number was passed in. Test that using the <code>jasmine.createSpy</code> capability.</li>\n<li>The file <code>config-retries.js</code> - configures the <code>retry</code> count of a configuration object. Test that, using the <code>spyOn</code> capability and the following test cases:\n- Case when <code>.retries</code> is a function, and it is called once and only once and with the expected input (<code>defaultRetries</code>).\n- Case when <code>.retries</code> is a number that number is the configured <code>retry</code>.\n- Case when <code>.retries</code> is not a function or a number, and the <code>defaultRetries</code> is the configured <code>retry</code> count.</li>\n</ul>\n<p>Use the next playground:</p>\n","cursorPosition":3872,"comp_id":"S8Ei-MxkI3wxwKI75-iHC"},"iteration":5,"hash":5,"saveVersion":12},{"type":"WebpackBin","mode":"edit","content":{"version":5,"theme":"default","showLineNumbers":true,"showConsole":true,"hideResultOutput":true,"hideOutputUrl":true,"hideCodeView":false,"loaders":{"babel":{"title":"React","config":{"es2015":true,"react":true},"enabled":true},"dart":{"title":"Dart","config":{"dart":true},"enabled":false},"ts-react":{"title":"Typescript React","config":{"ts-react":true},"enabled":false},"elm":{"title":"Elm","config":{"elm":true},"enabled":false},"vue":{"title":"Vue.js","config":{"vue":true},"enabled":false},"gojs-react":{"title":"GoJS React","config":{"gojs-react":true},"enabled":false}},"npmPackages":{"react":"15.6.1","react-dom":"15.6.1"},"outputHeight":300,"selectedApiKeys":{},"selectedEnvVars":{},"outputLayout":"desktop","codeContents":{"module":"/","id":0,"selectedId":9349120181695,"maxId":8708875079920,"children":[{"id":9295362567525,"module":"spec","leaf":false,"collapsed":true,"children":[{"id":3835113774835,"module":"support","leaf":false,"collapsed":true,"children":[{"id":5942417024393,"module":"jasmine.config.js","leaf":true,"data":{"content":"const SpecReporter = require('jasmine-spec-reporter').SpecReporter\r\n\r\njasmine.getEnv().clearReporters();\r\n\r\njasmine.getEnv().addReporter(\r\n  new SpecReporter({\r\n    // add jasmine-spec-reporter\r\n    spec: {\r\n      displayPending: true,\r\n    },\r\n  })\r\n)\r\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":3835113774835},{"id":3827245257826,"module":"jasmine.json","leaf":true,"data":{"content":"{\n  \"spec_dir\": \"src\",\n  \"spec_files\": [\n    \"**/*[sS]pec.js\"\n  ],\n  \"helpers\": [\n    \"../spec/support/jasmine.config.js\"\n  ],\n  \"stopSpecOnExpectationFailure\": false,\n  \"random\": false\n}\n","language":"javascript","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":3835113774835}],"parentId":9295362567525}],"parentId":0},{"id":8708875079920,"module":"src","leaf":false,"collapsed":true,"children":[{"id":5237880854178,"module":"exercise","leaf":false,"collapsed":true,"children":[{"id":7272028597036,"module":"config-retries.js","leaf":true,"data":{"content":"exports.configRetries = function config(/** @type {{ retries?: any; retry?: any; }} */ configObj) {\n  configObj = configObj || {};\n  const defaultRetries = 1;\n\n  if (typeof configObj.retries === 'function') {\n    const maybeRetries = configObj.retries(defaultRetries);\n    configObj.retry = typeof maybeRetries === 'number' ? maybeRetries : defaultRetries;\n  } else if (typeof configObj.retries === 'number') {\n    configObj.retry = configObj.retries;\n  } else if (!configObj.retry) {\n    configObj.retry = defaultRetries;\n  }\n\n  return configObj;\n};\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":5237880854178},{"id":203133659509,"module":"config-retries.spec.js","leaf":true,"data":{"content":"const { configRetries: config } = require('./config-retries');\n\ndescribe('config-retries', () => {\n  it('should call the retries callback if one passed', () => {\n    const c = {\n      retries: () => {},\n    }\n  });\n\n  it('should have the retry if one retries is a number', () => {\n    \n  });\n\n  it('should have the default retry if no retries passed in', () => {\n\n  });\n});\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":5237880854178},{"id":5203094753268,"module":"maybe-number.js","leaf":true,"data":{"content":"/**\n * @param {number} num\n * @param {(s: number) => any} callback\n */\nexports.maybeNumber = function maybeNumber(num, callback) {\n  if(typeof num === 'number' && typeof callback === 'function') {\n    return callback(num);\n  }\n}\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":5237880854178},{"id":9349120181695,"module":"maybe-number.spec.js","leaf":true,"data":{"content":"const { maybeNumber } = require('./maybe-number');\n\ndescribe('maybe-number', () => {\n\n  it('should call the callback if string passed in', () => {\n    const spy = jasmine.createSpy('callback');\n    maybeNumber(1, spy);\n    pending('remove this line and add test logic');\n  });\n\n  it('should not call the callback if no null, number or object passed in', () => {\n    pending('remove this line and add test logic');\n  });\n});\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":5237880854178}],"parentId":8708875079920},{"id":3789573946342,"module":"config.js","leaf":true,"data":{"content":"exports.config = function config(configObj) {\n    if(configObj && typeof configObj.configure === 'function') {\n        configObj = configObj.configure(configObj);\n    }\n\n    return configObj;\n}\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":8708875079920},{"id":7667879030813,"module":"config.spec.js","leaf":true,"data":{"content":"const { config } = require('./config');\n\ndescribe('config', () => {\n  it('should call the configure callback if one passed', () => {\n    const c = {\n      myConfig: 1,\n      configure: () => {},\n    };\n    const configureSpy = spyOn(c, 'configure');\n    config(c);\n\n    expect(configureSpy).toHaveBeenCalled();\n    expect(configureSpy).toHaveBeenCalledTimes(1);\n    expect(configureSpy).toHaveBeenCalledWith(jasmine.objectContaining({ myConfig: 1 }));\n  });\n\n  it('should replace the configure callback', () => {\n    const c = {\n      myConfig: 1,\n      configure: () => ({}),\n    };\n    const configureSpy = spyOn(c, 'configure').and.returnValue({ myConfig: 100 });\n    const actual = config(c);\n\n    expect(actual).toEqual({ myConfig: 100 });\n\n    expect(configureSpy).toHaveBeenCalledTimes(1);\n  });\n\n  it('should call through to the the configure callback', () => {\n    const c = {\n      myConfig: 1,\n      configure: (o) => {\n        return { myConfig: o.myConfig * 5 };\n      },\n    };\n    const configureSpy = spyOn(c, 'configure').and.callThrough();\n    const actual = config(c);\n\n    expect(actual).toEqual({ myConfig: 5 });\n\n    expect(configureSpy).toHaveBeenCalledTimes(1);\n  });\n});\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":8708875079920},{"id":4522036120992,"module":"maybe-string.js","leaf":true,"data":{"content":"/**\n * @param {string} str\n * @param {(s: string) => any} callback\n */\nexports.maybeString = function maybeString(str, callback) {\n  if(typeof str === 'string' && typeof callback === 'function') {\n    return callback(str);\n  }\n}\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":8708875079920},{"id":8502890384471,"module":"maybe-string.spec.js","leaf":true,"data":{"content":"// @ts-nocheck\nconst { maybeString } = require('./maybe-string');\n\ndescribe('maybe-string', () => {\n\n  it('should call the callback if string passed in', () => {\n    const spy = jasmine.createSpy('callback');\n    maybeString('s', spy);\n\n    expect(spy).toHaveBeenCalled();\n    expect(spy).toHaveBeenCalledTimes(1);\n    expect(spy).toHaveBeenCalledWith('s');\n  });\n\n  it('should not call the callback if no null, number or object passed in', () => {\n    const spy = jasmine.createSpy('callback');\n    maybeString(null, spy);\n    maybeString(undefined, spy);\n    maybeString(1, spy);\n    maybeString({}, spy);\n\n    expect(spy).not.toHaveBeenCalled();\n  });\n\n  // it('should return the result of callback when string', () => {\n  //   const actual = maybeString('my string', s => s.length);\n\n  //   expect(actual).toBe(9);\n  // });\n});\n","language":"jsx","staticFile":false,"hidden":false,"highlightedLines":""},"parentId":8708875079920}],"parentId":0}],"importedGithubPath":"https://github.com/gparlakov/using-jasmine-and-karma-to-unit-test-your-angular-app/tree/main/mocking-dependencies","judge":{"judgeActive":false}},"comp_id":"J1jX0A1M5kFJ-1ktH_1Jm","dockerJob":{"key":"7IgoXRRQCavQ48Yy3YCL0","name":"live Jasmine","inputFileName":"src/main.ts","runScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec && cp -r /usercode/** .","ports":"9876","startScript":"cd /usr/local/educative/unit-testing-course && rm -rf src && rm -rf spec &&  cp -r /usercode/** . && node_modules/.bin/nodemon -w ../unit-testing-course/ ./node_modules/.bin/jasmine","jobType":"Live","forceRelaunchOnCompChange":true,"runInLiveContainer":true}},"iteration":11,"hash":6,"saveVersion":7},{"type":"SpoilerEditor","mode":"edit","content":{"version":"3.0","text":"```js\nconst { maybeNumber } = require('./maybe-number');\n\ndescribe('maybe-number', () => {\n\n  it('should call the callback if string passed in', () => {\n    const spy = jasmine.createSpy('callback');\n    maybeNumber(1, spy);\n\n    expect(spy).toHaveBeenCalled();\n    expect(spy).toHaveBeenCalledTimes(1);\n    expect(spy).toHaveBeenCalledWith(1);\n  });\n\n  it('should not call the callback if no null, number or object passed in', () => {\n    const spy = jasmine.createSpy('callback');\n    maybeNumber(null, spy);\n    maybeNumber(undefined, spy);\n    maybeNumber('1', spy);\n    maybeNumber({}, spy);\n\n    expect(spy).not.toHaveBeenCalled();\n  });\n});\n\n```","mdHtml":"<pre><code class=\"language-js\">const { maybeNumber } = require('./maybe-number');\n\ndescribe('maybe-number', () =&gt; {\n\n  it('should call the callback if string passed in', () =&gt; {\n    const spy = jasmine.createSpy('callback');\n    maybeNumber(1, spy);\n\n    expect(spy).toHaveBeenCalled();\n    expect(spy).toHaveBeenCalledTimes(1);\n    expect(spy).toHaveBeenCalledWith(1);\n  });\n\n  it('should not call the callback if no null, number or object passed in', () =&gt; {\n    const spy = jasmine.createSpy('callback');\n    maybeNumber(null, spy);\n    maybeNumber(undefined, spy);\n    maybeNumber('1', spy);\n    maybeNumber({}, spy);\n\n    expect(spy).not.toHaveBeenCalled();\n  });\n});\n\n</code></pre>\n","showHintText":"Show Hint maybe-number","hideHintText":"Hide Hint","showIcon":true,"comp_id":"sh-tQnbr_dwk9Gk-7Dpho"},"iteration":6,"hash":7,"saveVersion":4},{"type":"SpoilerEditor","mode":"edit","content":{"version":"3.0","text":"```js\nconst { configRetries: config } = require('./config-retries');\n\ndescribe('config-retries', () => {\n  it('should call the retries callback if one passed', () => {\n    const c = {\n      retries: () => {},\n    };\n    const retries = spyOn(c, 'retries');\n    config(c);\n\n    expect(retries).toHaveBeenCalled();\n    expect(retries).toHaveBeenCalledTimes(1);\n    expect(retries).toHaveBeenCalledWith(1);\n  });\n\n  it('should have the retry if one retries is a number', () => {\n    const c = {\n      retries: 5,\n    };\n    const actual = config(c);\n\n    expect(actual).toEqual(jasmine.objectContaining({ retry: 5 }));\n  });\n\n  it('should have the default retry if no retries passed in', () => {\n    const c = {};\n    const actual = config(c);\n\n    expect(actual).toEqual({ retry: 1 });\n  });\n});\n\n```","mdHtml":"<pre><code class=\"language-js\">const { configRetries: config } = require('./config-retries');\n\ndescribe('config-retries', () =&gt; {\n  it('should call the retries callback if one passed', () =&gt; {\n    const c = {\n      retries: () =&gt; {},\n    };\n    const retries = spyOn(c, 'retries');\n    config(c);\n\n    expect(retries).toHaveBeenCalled();\n    expect(retries).toHaveBeenCalledTimes(1);\n    expect(retries).toHaveBeenCalledWith(1);\n  });\n\n  it('should have the retry if one retries is a number', () =&gt; {\n    const c = {\n      retries: 5,\n    };\n    const actual = config(c);\n\n    expect(actual).toEqual(jasmine.objectContaining({ retry: 5 }));\n  });\n\n  it('should have the default retry if no retries passed in', () =&gt; {\n    const c = {};\n    const actual = config(c);\n\n    expect(actual).toEqual({ retry: 1 });\n  });\n});\n\n</code></pre>\n","showHintText":"Show Hint config-retries","hideHintText":"Hide Hint","showIcon":true,"comp_id":"npIteVWmRx8f9KZT5SHC9"},"iteration":5,"hash":8,"saveVersion":4}],"summary":{"description":"In this lesson, we'll take a look at functions that take other functions as parameters and depend on them. To test these we'll learn how to mock a function or an object's method.","titleUpdated":true,"title":"How to Test a Functions Depending on Other Functions","tags":["spyOn","jasmine.createSpy","jasmine.createSpyObj"]}}